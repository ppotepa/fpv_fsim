#include "AssetIdGenerator.h"
#ifdef HAVE_PUGIXML
#include "platform/IXmlParser.h"
#include "platform/PugiXmlParser.h"
#endif
#include <filesystem>
#include <fstream>
#include <iostream>
#include <algorithm>
#include <iomanip>
#include <functional>

AssetIdGenerator::AssetIdGenerator()
#ifdef HAVE_PUGIXML
    : xmlParser_(std::make_unique<PugiXmlParser>())
    , nextSequentialId_(1)
#else
    : nextSequentialId_(1)
#endif
    , useHashBasedIds_(false)
    , totalPackagesScanned_(0)
    , totalScenesScanned_(0)
    , totalFilesScanned_(0)
{
}

AssetIdGenerator::~AssetIdGenerator() = default;

bool AssetIdGenerator::scanPackageFile(const std::string& packageFile)
{
    if (!std::filesystem::exists(packageFile))
    {
        std::cerr << "Package file does not exist: " << packageFile << std::endl;
        return false;
    }

#ifdef HAVE_PUGIXML
    if (!xmlParser_->loadFile(packageFile))
    {
        std::cerr << "Failed to parse package file: " << packageFile 
                  << " - " << xmlParser_->getLastError() << std::endl;
        return false;
    }

    std::filesystem::path packagePath(packageFile);
    std::string packageName = packagePath.parent_path().filename().string();
    
    totalPackagesScanned_++;
    totalFilesScanned_++;
    
    return processAssetDefinitions(packageName, packageFile);
#else
    // Simplified mode without XML parsing
    std::cout << "Codegen Demo Mode (XML parsing disabled)" << std::endl;
    std::cout << "Scanning: " << packageFile << std::endl;
    
    std::filesystem::path packagePath(packageFile);
    std::string packageName = packagePath.parent_path().filename().string();
    
    // Create some demo assets
    AssetInfo demoTexture;
    demoTexture.name = "demo_texture";
    demoTexture.type = "texture";
    demoTexture.package = packageName;
    demoTexture.numericId = nextSequentialId_++;
    demoTexture.sourceFile = packageFile;
    assets_[demoTexture.name] = demoTexture;
    idToName_[demoTexture.numericId] = demoTexture.name;
    
    AssetInfo demoMesh;
    demoMesh.name = "demo_mesh";
    demoMesh.type = "mesh";
    demoMesh.package = packageName;
    demoMesh.numericId = nextSequentialId_++;
    demoMesh.sourceFile = packageFile;
    assets_[demoMesh.name] = demoMesh;
    idToName_[demoMesh.numericId] = demoMesh.name;
    
    totalPackagesScanned_++;
    totalFilesScanned_++;
    
    std::cout << "Created demo assets: " << demoTexture.name << " (ID: " << demoTexture.numericId 
              << "), " << demoMesh.name << " (ID: " << demoMesh.numericId << ")" << std::endl;
    
    return true;
#endif
}
}

bool AssetIdGenerator::scanSceneFile(const std::string& sceneFile)
{
    if (!std::filesystem::exists(sceneFile))
    {
        std::cerr << "Scene file does not exist: " << sceneFile << std::endl;
        return false;
    }

    if (!xmlParser_->loadFile(sceneFile))
    {
        std::cerr << "Failed to parse scene file: " << sceneFile 
                  << " - " << xmlParser_->getLastError() << std::endl;
        return false;
    }

    totalScenesScanned_++;
    totalFilesScanned_++;
    
    return processAssetReferences(sceneFile);
}

bool AssetIdGenerator::scanDirectory(const std::string& directory)
{
    if (!std::filesystem::exists(directory))
    {
        std::cerr << "Directory does not exist: " << directory << std::endl;
        return false;
    }

    bool success = true;
    
    for (const auto& entry : std::filesystem::recursive_directory_iterator(directory))
    {
        if (entry.is_regular_file())
        {
            std::string filename = entry.path().filename().string();
            std::string extension = entry.path().extension().string();
            
            if (extension == ".xml")
            {
                if (filename == "package.xml")
                {
                    success &= scanPackageFile(entry.path().string());
                }
                else if (filename.find("scene") != std::string::npos)
                {
                    success &= scanSceneFile(entry.path().string());
                }
            }
        }
    }
    
    return success;
}

bool AssetIdGenerator::generateCppHeader(const std::string& outputFile, const std::string& namespaceName)
{
    std::ofstream file(outputFile);
    if (!file.is_open())
    {
        std::cerr << "Failed to create header file: " << outputFile << std::endl;
        return false;
    }

    // Generate header guard
    std::string guardName = "GENERATED_ASSET_IDS_H";
    std::transform(guardName.begin(), guardName.end(), guardName.begin(), ::toupper);

    file << "/*\n";
    file << " * AUTO-GENERATED FILE - DO NOT EDIT\n";
    file << " * Generated by AssetIdGenerator\n";
    file << " * Contains stable numeric IDs for all assets\n";
    file << " */\n\n";
    file << "#ifndef " << guardName << "\n";
    file << "#define " << guardName << "\n\n";
    file << "#include <cstdint>\n\n";

    if (!namespaceName.empty())
    {
        file << "namespace " << namespaceName << "\n{\n\n";
    }

    file << "// Asset ID type definition\n";
    file << "using AssetId = uint32_t;\n\n";

    // Group assets by type
    std::unordered_map<std::string, std::vector<AssetInfo>> assetsByType;
    for (const auto& [name, info] : assets_)
    {
        assetsByType[info.type].push_back(info);
    }

    // Generate constants for each type
    for (const auto& [type, assetList] : assetsByType)
    {
        std::string sectionComment = "// " + type + " assets";
        std::transform(sectionComment.begin(), sectionComment.end(), sectionComment.begin(), ::toupper);
        
        file << sectionComment << "\n";
        
        for (const auto& asset : assetList)
        {
            std::string constName = sanitizeIdentifier(asset.name);
            std::transform(constName.begin(), constName.end(), constName.begin(), ::toupper);
            
            file << "static constexpr AssetId " << constName << " = " << asset.numericId;
            file << "; // " << asset.name << " from " << asset.package << "\n";
        }
        file << "\n";
    }

    if (!namespaceName.empty())
    {
        file << "} // namespace " << namespaceName << "\n\n";
    }

    file << "#endif // " << guardName << "\n";
    
    std::cout << "Generated C++ header: " << outputFile << " with " << assets_.size() << " asset IDs" << std::endl;
    return true;
}

bool AssetIdGenerator::generateBinaryTable(const std::string& outputFile)
{
    std::ofstream file(outputFile, std::ios::binary);
    if (!file.is_open())
    {
        std::cerr << "Failed to create binary file: " << outputFile << std::endl;
        return false;
    }

    // Binary format:
    // Header: [magic(4)] [version(4)] [count(4)]
    // Entry: [id(4)] [name_length(4)] [name_data(name_length)] [type_length(4)] [type_data(type_length)]

    uint32_t magic = 0x41534554; // "ASET"
    uint32_t version = 1;
    uint32_t count = static_cast<uint32_t>(assets_.size());

    file.write(reinterpret_cast<const char*>(&magic), sizeof(magic));
    file.write(reinterpret_cast<const char*>(&version), sizeof(version));
    file.write(reinterpret_cast<const char*>(&count), sizeof(count));

    for (const auto& [name, info] : assets_)
    {
        uint32_t nameLength = static_cast<uint32_t>(info.name.length());
        uint32_t typeLength = static_cast<uint32_t>(info.type.length());

        file.write(reinterpret_cast<const char*>(&info.numericId), sizeof(info.numericId));
        file.write(reinterpret_cast<const char*>(&nameLength), sizeof(nameLength));
        file.write(info.name.c_str(), nameLength);
        file.write(reinterpret_cast<const char*>(&typeLength), sizeof(typeLength));
        file.write(info.type.c_str(), typeLength);
    }

    std::cout << "Generated binary table: " << outputFile << " with " << assets_.size() << " entries" << std::endl;
    return true;
}

bool AssetIdGenerator::generateJsonMapping(const std::string& outputFile)
{
    std::ofstream file(outputFile);
    if (!file.is_open())
    {
        std::cerr << "Failed to create JSON file: " << outputFile << std::endl;
        return false;
    }

    file << "{\n";
    file << "  \"version\": 1,\n";
    file << "  \"generated_at\": \"" << std::chrono::system_clock::now().time_since_epoch().count() << "\",\n";
    file << "  \"total_assets\": " << assets_.size() << ",\n";
    file << "  \"assets\": {\n";

    bool first = true;
    for (const auto& [name, info] : assets_)
    {
        if (!first) file << ",\n";
        first = false;

        file << "    \"" << info.name << "\": {\n";
        file << "      \"id\": " << info.numericId << ",\n";
        file << "      \"type\": \"" << info.type << "\",\n";
        file << "      \"package\": \"" << info.package << "\",\n";
        file << "      \"source\": \"" << info.sourceFile << "\"\n";
        file << "    }";
    }

    file << "\n  }\n";
    file << "}\n";

    std::cout << "Generated JSON mapping: " << outputFile << " with " << assets_.size() << " entries" << std::endl;
    return true;
}

void AssetIdGenerator::setStartingId(uint32_t startId)
{
    nextSequentialId_ = startId;
}

void AssetIdGenerator::setUseHashBasedIds(bool useHashes)
{
    useHashBasedIds_ = useHashes;
}

std::vector<AssetInfo> AssetIdGenerator::getDiscoveredAssets() const
{
    std::vector<AssetInfo> result;
    result.reserve(assets_.size());
    
    for (const auto& [name, info] : assets_)
    {
        result.push_back(info);
    }
    
    return result;
}

std::string AssetIdGenerator::getStatistics() const
{
    std::ostringstream oss;
    oss << "Asset Discovery Statistics:\n";
    oss << "  Total assets discovered: " << assets_.size() << "\n";
    oss << "  Packages scanned: " << totalPackagesScanned_ << "\n";
    oss << "  Scenes scanned: " << totalScenesScanned_ << "\n";
    oss << "  Files processed: " << totalFilesScanned_ << "\n";
    
    // Count by type
    std::unordered_map<std::string, size_t> typeCount;
    for (const auto& [name, info] : assets_)
    {
        typeCount[info.type]++;
    }
    
    oss << "  Assets by type:\n";
    for (const auto& [type, count] : typeCount)
    {
        oss << "    " << type << ": " << count << "\n";
    }
    
    return oss.str();
}

void AssetIdGenerator::clear()
{
    assets_.clear();
    idToName_.clear();
    nextSequentialId_ = 1;
    totalPackagesScanned_ = 0;
    totalScenesScanned_ = 0;
    totalFilesScanned_ = 0;
}

bool AssetIdGenerator::processAssetDefinitions(const std::string& packageName, const std::string& sourceFile)
{
    // Process different asset types
    std::vector<std::string> assetTypes = {"texture", "mesh", "material", "shader", "font", "audio"};
    
    for (const std::string& assetType : assetTypes)
    {
        auto elements = xmlParser_->getElementsWithName(assetType);
        for (const auto& elementPath : elements)
        {
            std::string id = xmlParser_->getElementAttribute(elementPath, "id");
            if (!id.empty())
            {
                registerAsset(id, assetType, packageName, sourceFile);
            }
        }
    }
    
    return true;
}

bool AssetIdGenerator::processAssetReferences(const std::string& sceneFile)
{
    // Look for asset references in scene files
    // These might be in material_id, mesh_id, texture_id attributes, etc.
    
    std::vector<std::string> refAttributes = {"material_id", "mesh_id", "texture_id", "shader_id"};
    
    for (const std::string& attr : refAttributes)
    {
        // This is a simplified approach - in a real implementation,
        // you'd traverse the entire XML tree looking for these attributes
        // For now, just mark that we've processed the scene file
    }
    
    return true;
}

void AssetIdGenerator::registerAsset(const std::string& name, const std::string& type, 
                                   const std::string& package, const std::string& sourceFile)
{
    // Check if asset already exists
    auto it = assets_.find(name);
    if (it != assets_.end())
    {
        // Asset already registered, just update source info if needed
        return;
    }
    
    AssetInfo info;
    info.name = name;
    info.type = type;
    info.package = package;
    info.sourceFile = sourceFile;
    info.numericId = generateNumericId(name);
    
    assets_[name] = info;
    idToName_[info.numericId] = name;
    
    std::cout << "Registered asset: " << name << " (" << type << ") -> ID " << info.numericId << std::endl;
}

uint32_t AssetIdGenerator::generateNumericId(const std::string& assetName)
{
    if (useHashBasedIds_)
    {
        uint32_t hash = hashString(assetName);
        
        // Check for collision
        auto it = idToName_.find(hash);
        while (it != idToName_.end() && it->second != assetName)
        {
            // Simple collision resolution: increment hash
            hash = (hash + 1) | 0x80000000; // Set high bit to distinguish from sequential IDs
            it = idToName_.find(hash);
        }
        
        return hash;
    }
    else
    {
        return nextSequentialId_++;
    }
}

uint32_t AssetIdGenerator::hashString(const std::string& input) const
{
    // Simple FNV-1a hash implementation
    uint32_t hash = 2166136261u;
    for (char c : input)
    {
        hash ^= static_cast<uint8_t>(c);
        hash *= 16777619u;
    }
    return hash;
}

std::string AssetIdGenerator::sanitizeIdentifier(const std::string& input) const
{
    std::string result;
    result.reserve(input.length());
    
    for (char c : input)
    {
        if (std::isalnum(c))
        {
            result += c;
        }
        else
        {
            result += '_';
        }
    }
    
    // Ensure it doesn't start with a digit
    if (!result.empty() && std::isdigit(result[0]))
    {
        result = "ASSET_" + result;
    }
    
    return result;
}
