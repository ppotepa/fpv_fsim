// Simple version of AssetIdGenerator without XML dependencies for demo purposes
#include "AssetIdGenerator.h"
#include <filesystem>
#include <fstream>
#include <iostream>
#include <algorithm>
#include <iomanip>
#include <functional>

AssetIdGenerator::AssetIdGenerator()
    : nextSequentialId_(1), useHashBasedIds_(false), totalPackagesScanned_(0), totalScenesScanned_(0), totalFilesScanned_(0)
{
}

AssetIdGenerator::~AssetIdGenerator() = default;

bool AssetIdGenerator::scanPackageFile(const std::string &packageFile)
{
    if (!std::filesystem::exists(packageFile))
    {
        std::cerr << "Package file does not exist: " << packageFile << std::endl;
        return false;
    }

    // Simplified mode without XML parsing for demo
    std::cout << "Codegen Demo Mode" << std::endl;
    std::cout << "Scanning: " << packageFile << std::endl;

    std::filesystem::path packagePath(packageFile);
    std::string packageName = packagePath.parent_path().filename().string();

    // Create some demo assets based on the package name
    std::vector<std::pair<std::string, std::string>> demoAssets = {
        {"demo_texture", "texture"},
        {"demo_mesh", "mesh"},
        {"demo_material", "material"},
        {"demo_shader", "shader"}};

    for (const auto &[assetName, assetType] : demoAssets)
    {
        AssetInfo asset;
        asset.name = packageName + "_" + assetName;
        asset.type = assetType;
        asset.package = packageName;
        asset.numericId = nextSequentialId_++;
        asset.sourceFile = packageFile;

        assets_[asset.name] = asset;
        idToName_[asset.numericId] = asset.name;

        std::cout << "  Created " << asset.type << ": " << asset.name
                  << " (ID: " << asset.numericId << ")" << std::endl;
    }

    totalPackagesScanned_++;
    totalFilesScanned_++;

    return true;
}

bool AssetIdGenerator::generateCppHeader(const std::string &outputFile)
{
    std::cout << "Generating C++ header: " << outputFile << std::endl;

    // Create output directory if it doesn't exist
    std::filesystem::path outputPath(outputFile);
    std::filesystem::create_directories(outputPath.parent_path());

    std::ofstream output(outputFile);
    if (!output.is_open())
    {
        std::cerr << "Failed to create output file: " << outputFile << std::endl;
        return false;
    }

    // Generate header content
    output << "#ifndef ASSET_IDS_H\n";
    output << "#define ASSET_IDS_H\n\n";
    output << "// Auto-generated asset ID constants\n";
    output << "// Generated by AssetIdGenerator tool\n\n";
    output << "#include <cstdint>\n\n";
    output << "namespace Assets {\n\n";
    output << "using AssetId = uint32_t;\n\n";
    output << "// Asset ID constants\n";

    // Sort assets by ID for consistent output
    std::vector<std::pair<uint32_t, std::string>> sortedAssets;
    for (const auto &[name, info] : assets_)
    {
        sortedAssets.emplace_back(info.numericId, name);
    }
    std::sort(sortedAssets.begin(), sortedAssets.end());

    // Generate constants
    for (const auto &[id, name] : sortedAssets)
    {
        const AssetInfo &info = assets_.at(name);

        // Convert to valid C++ identifier
        std::string constName = name;
        std::replace(constName.begin(), constName.end(), '-', '_');
        std::replace(constName.begin(), constName.end(), '.', '_');
        std::transform(constName.begin(), constName.end(), constName.begin(), ::toupper);

        output << "constexpr AssetId " << constName << " = " << id
               << "; // " << info.type << " from " << info.package << "\n";
    }

    output << "\n} // namespace Assets\n\n";
    output << "#endif // ASSET_IDS_H\n";

    output.close();

    std::cout << "Generated " << assets_.size() << " asset ID constants" << std::endl;
    return true;
}

void AssetIdGenerator::printStatistics() const
{
    std::cout << "\nAsset ID Generation Statistics:" << std::endl;
    std::cout << "===============================" << std::endl;
    std::cout << "Packages scanned: " << totalPackagesScanned_ << std::endl;
    std::cout << "Files processed: " << totalFilesScanned_ << std::endl;
    std::cout << "Total assets found: " << assets_.size() << std::endl;

    // Count by type
    std::unordered_map<std::string, size_t> typeCounts;
    for (const auto &[name, info] : assets_)
    {
        typeCounts[info.type]++;
    }

    std::cout << "\nAssets by type:" << std::endl;
    for (const auto &[type, count] : typeCounts)
    {
        std::cout << "  " << type << ": " << count << std::endl;
    }
}

const std::unordered_map<std::string, AssetInfo> &AssetIdGenerator::getAssets() const
{
    return assets_;
}
