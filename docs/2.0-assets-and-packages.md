# 2.0 Enhanced Package Modularity Architecture

## Overview

The FPV Flight Simulator implements a revolutionary **component-driven package architecture** that cleanly separates assets from scenes while providing powerful extension points through a **code-behind mechanism**. This architecture promotes modularity, reusability, and extensibility without requiring changes to core C++ code.

## Key Architectural Principles

### 1. Hierarchical Package Organization
```
PACKAGE (Top-level container)
├── ASSETS (Reusable resources)
│   ├── 3D Models (.gltf, .obj, primitives)
│   ├── Materials (shaders, textures, properties)
│   ├── Textures (.png, .ktx2, procedural)
│   ├── Audio (.wav, .ogg, spatial audio)
│   └── Shaders (GLSL, compute shaders)
└── SCENES (Individual environments)
    ├── Scene1.xml (Environment definition)
    ├── Scene2.xml (Lighting, camera, entities)
    └── SceneN.xml (Complete scene compositions)
```

### 2. Component-Driven Entity System
Every entity in a scene is composed of:
- **Transform Component**: Position, rotation, scale
- **Mesh Component**: 3D geometry reference
- **Material Component**: Surface properties reference  
- **Behavior Component**: Custom C++ logic via `codeBehind`
- **Physics Component**: Collision, dynamics (optional)
- **Audio Component**: Spatial sound (optional)

### 3. Code-Behind Integration
XML entities can specify `codeBehind="namespace.ClassName"` to link declarative scene definitions with programmatic C++ behaviors:

```xml
<entity id="cloudLayer" codeBehind="behaviors.CloudSystem">
    <params>
        <cloud_density>0.7</cloud_density>
        <drift_speed>0.02</drift_speed>
        <spawn_rate>0.1</spawn_rate>
    </params>
</entity>
```

## Enhanced Package Structure

### Modern Asset Pipeline
The simulation architecture now uses a **declarative-first approach** where XML drives the composition:

```
assets/packages/DeveloperPackage/
├── package.xml              // Main package definition
├── materials.xml            // Material library
├── scenes/                  // Individual scene files
│   ├── RedCubeScene.xml    // Simple test scene
│   ├── EarthScene.xml      // Complex planet scene
│   └── FlightScene.xml     // Drone simulation scene
├── textures/               // Image assets
│   ├── earth_albedo.png
│   └── cloud_noise.ktx2
├── models/                 // 3D geometry
│   ├── drone_frame.gltf
│   └── terrain_chunk.obj
├── audio/                  // Sound assets
│   ├── wind_ambient.wav
│   └── engine_startup.ogg
└── behaviors/              // C++ behavior implementations
    ├── CloudSystem.cpp
    ├── WeatherController.cpp
    └── FlightDynamics.cpp
```
## Package.xml Structure

The enhanced `package.xml` follows a clean hierarchical structure:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<package name="DeveloperPackage" version="1.0">
    <!-- ASSETS: Reusable resources -->
    <assets>
        <!-- 3D Models -->
        <asset type="mesh" id="CubeMesh">
            <primitive type="cube" size="1.0" />
        </asset>
        <asset type="mesh" id="DroneFrame">
            <path>models/drone_frame.gltf</path>
            <properties>
                <scale>1.0</scale>
                <optimization>aggressive</optimization>
            </properties>
        </asset>
        
        <!-- Materials -->
        <asset type="material" id="RedMaterial">
            <shader>BasicShader</shader>
            <params>
                <color r="1.0" g="0.0" b="0.0" a="1.0" />
                <roughness>0.8</roughness>
                <metallic>0.0</metallic>
            </params>
        </asset>
        
        <!-- Textures -->
        <asset type="texture" id="EarthAlbedo">
            <path>textures/earth_albedo.ktx2</path>
            <properties mipmaps="true" filter="trilinear" />
        </asset>
        
        <!-- Audio -->
        <asset type="audio" id="WindAmbient">
            <path>audio/wind_ambient.wav</path>
            <properties looping="true" spatial="true" />
        </asset>
    </assets>

    <!-- SCENES: Individual environments -->
    <scenes>
        <scene id="RedCubeScene" name="Simple Test Scene">
            <environment>
                <background color="0.0 0.0 0.0" />
                <ambient_light intensity="0.3" color="0.2 0.2 0.3" />
                <directional_light direction="0.5 -1.0 0.5" 
                                 color="1.0 1.0 1.0" intensity="1.0" />
            </environment>
            
            <camera>
                <position x="0" y="0" z="5" />
                <target x="0" y="0" z="0" />
                <up x="0" y="1" z="0" />
                <fov>45.0</fov>
            </camera>
            
            <entities>
                <!-- Entity with code-behind behavior -->
                <entity id="redCube" name="RedCube" 
                        codeBehind="behaviors.RotatingObject">
                    <transform>
                        <position x="0" y="0" z="0" />
                        <rotation x="0" y="0" z="0" w="1" />
                        <scale x="1" y="1" z="1" />
                    </transform>
                    <components>
                        <mesh asset="CubeMesh" />
                        <material asset="RedMaterial" />
                        <renderable visible="true" />
                    </components>
                    <!-- Parameters for the behavior -->
                    <params>
                        <rotation_speed>0.5</rotation_speed>
                        <rotation_axis>0 1 0</rotation_axis>
                    </params>
                </entity>
            </entities>
        </scene>
    </scenes>
</package>
```

## Integration with C++ Engine

### Entity Factory Enhancement

The `EntityFactory` now supports the enhanced architecture:

```cpp
class EntityFactory {
public:
    std::unique_ptr<Entity> createFromXML(const XmlNode& entityNode, 
                                         const AssetRegistry& assets) {
        auto entity = std::make_unique<Entity>(
            entityNode.attribute("id").value(),
            entityNode.attribute("name").value()
        );
        
        // Add transform component
        addTransformComponent(entity.get(), entityNode.child("transform"));
        
        // Add mesh and material components
        addRenderComponents(entity.get(), entityNode.child("components"), assets);
        
        // Attach code-behind behavior if specified
        std::string codeBehind = entityNode.attribute("codeBehind").value();
        if (!codeBehind.empty()) {
            attachCodeBehavior(entity.get(), codeBehind, 
                             entityNode.child("params"));
        }
        
        return entity;
    }

private:
    void attachCodeBehavior(Entity* entity, const std::string& behaviorName,
                          const XmlNode& params) {
        auto behavior = BehaviorRegistry::instance().create(behaviorName);
        if (behavior) {
            // Parse XML parameters
            BehaviorParams behaviorParams;
            for (auto& param : params.children()) {
                behaviorParams.set(param.name(), param.text().value());
            }
            
            // Initialize and attach behavior
            behavior->initialize(*entity, behaviorParams);
            entity->attachBehavior(std::move(behavior));
        }
    }
};
```

### Behavior System Implementation

Code-behind behaviors are implemented as C++ classes:

```cpp
// Base behavior interface
class EntityBehavior {
public:
    virtual ~EntityBehavior() = default;
    virtual void initialize(Entity& entity, const BehaviorParams& params) = 0;
    virtual void update(Entity& entity, float deltaTime) = 0;
    virtual void onEvent(Entity& entity, const IEvent& event) {}
};

// Example rotating object behavior
class RotatingObject : public EntityBehavior {
public:
    void initialize(Entity& entity, const BehaviorParams& params) override {
        rotationSpeed = params.getFloat("rotation_speed", 1.0f);
        rotationAxis = params.getVector3("rotation_axis", {0, 1, 0});
    }
    
    void update(Entity& entity, float deltaTime) override {
        if (auto transform = entity.getComponent<TransformC>()) {
            float angle = rotationSpeed * deltaTime;
            Quaternion rotation = Quaternion::fromAxisAngle(rotationAxis, angle);
            transform->orientation = transform->orientation * rotation;
        }
    }

private:
    float rotationSpeed = 1.0f;
    Vector3 rotationAxis = {0, 1, 0};
};

// Register behavior in system
REGISTER_BEHAVIOR("behaviors.RotatingObject", RotatingObject);
```

## Enhanced Asset Pipeline Benefits

### 1. **Modularity and Reusability**
- Assets defined once, referenced multiple times across scenes
- Scene compositions independent of asset implementation
- Easy asset swapping without scene modifications

### 2. **Declarative Scene Authoring**
- Non-programmers can create complex scenes via XML
- Visual scene editors can generate compatible XML
- Rapid prototyping through configuration changes

### 3. **Code-Behind Extensibility**
- Custom behaviors implemented in high-performance C++
- XML parameters allow behavior customization
- Plugin-like architecture for extending entity capabilities

### 4. **Hot-Reload Support**
- Asset changes detected and reloaded at runtime
- Scene modifications reflected immediately
- Behavior parameter adjustments without recompilation

### 5. **Cross-Platform Compatibility**
- Asset paths relative to package directory
- Platform-specific optimizations during asset cooking
- Consistent scene behavior across Windows/ARM64

## Legacy Migration Path

Existing packages can be gradually migrated:

1. **Extract Assets**: Move shared resources to `<assets>` section
2. **Restructure Scenes**: Convert complex entities to scene-based definitions  
3. **Add Code-Behind**: Replace hardcoded behaviors with parameterized C++ classes
4. **Optimize Assets**: Use new asset cooking pipeline for better performance

This enhanced architecture provides a solid foundation for scalable content creation while maintaining the flexibility and performance requirements of the FPV flight simulator.
│   │       ├── src/
│   │       ├── include/
│   │       └── CMakeLists.txt
│   ├── environment/           // World generation assets and configurations
│   │   ├── world_gen/
│   │   │   ├── scenes/
│   │   │   │   └── city_day_scene.xml     // Scene definition
│   │   │   │   └── mountain_range_scene.xml
│   │   │   ├── furniture/                 // Parametric furniture assets
│   │   │   │   ├── table_office.xml
│   │   │   │   └── shelf_wall.xml
│   │   │   ├── textures/
│   │   │   │   └── terrain_grass_pbr.png
│   │   │   └── CMakeLists.txt
│   │   ├── assets/            // Generic environment assets
│   │   │   ├── models/
│   │   │   │   └── tree_pine_lod0.gltf
│   │   │   ├── textures/
│   │   │   │   └── water_normal.png
│   │   │   ├── sounds/
│   │   │   │   └── wind_ambient.ogg
│   │   │   └── shaders/
│   │   │       ├── terrain_shader.glsl
│   │   │       └── water_shader.glsl
│   │   └── CMakeLists.txt
│   └── ui/                    // User interface assets and configurations
│       ├── assets/
│       │   ├── sounds/
│       │   │   └── click.ogg
│       │   └── images/
│       │       └── hud_icon_battery.png
│       ├── config/
│       │   └── hud_layout_standard.xml    // HUD layout definition
│       │   └── menu_main.xml              // Main menu definition
│       ├── src/
│       ├── include/
│       └── CMakeLists.txt
└── CMakeLists.txt             // Main CMake for the entire project

This structure aligns with the concept of mini-domains (e.g., physics/, vehicles/, environment/) and allows for logical grouping of related code and assets [1]. Asset categories like models/, textures/, shaders/, and sounds/ are explicitly supported [6]. The use of config/ folders for XML definitions emphasizes data-driven configuration, which is crucial for extensibility [5, 7, 8].
Example XML Files for Scene and Components
XML files are used to define various aspects of the simulation, from scene configurations to component parameters and asset properties, promoting a data-driven approach [5, 7].
1. Example XML for a Scene ()
This XML would define the parameters for procedural generation of a city environment, which would be processed by the WorldGenSystem [7, 9]. It draws on concepts like procedural terrain, buildings with interiors, and wind models [10].
<!-- packages/environment/world_gen/scenes/city_day_scene.xml -->
<Scene name="CityDay" description="A sprawling urban landscape with dynamic weather.">
    <WorldGenerator>
        <Terrain type="ProceduralTerran">
            <Seed value="12345" />
            <HeightMapScale x="2000" z="2000" />
            <NoiseLayers>
                <Layer type="Perlin" frequency="0.005" amplitude="50" octaves="4" />
                <Layer type="Worley" frequency="0.02" amplitude="10" />
            </HeightMapScale>
            <Biome type="Urban" /> <!-- References a 'Biome' asset definition -->
        </Terrain>
        <BuildingsGeneration>
            <BuildingDensity min="0.3" max="0.7" />
            <AverageFloorHeight value="3.5" />
            <WindowConfiguration targetWindowWallRatio="0.35" minBaySpacing="2.5" maxBaySpacing="4.0" />
            <InteriorConfiguration enableInteriors="true" furnitureDensity="0.08">
                <FurnitureTemplates>
                    <FurnitureAsset ref="office_table_basic.xml" /> <!-- References parametric furniture asset -->
                    <FurnitureAsset ref="wall_shelf_standard.xml" />
                </FurnitureTemplates>
            </InteriorConfiguration>
        </BuildingsGeneration>
    </WorldGenerator>
    <EnvironmentalPhysics>
        <Gravity vector="0,-9.81,0" />
        <Atmosphere type="ISAStandard">
            <SeaLevelDensity value="1.225" />
            <ScaleHeight value="8500" />
        </Atmosphere>
        <WindModel type="AdvancedPerlin">
            <BaseWind vector="5,0,0" />
            <GustStrength value="10" frequency="0.1" decayTime="5.0" />
            <TurbulenceScale x="50" y="50" z="50" time="10" amplitude="1.0" />
            <BuildingTurbulence enable="true" />
        </WindModel>
    </EnvironmentalPhysics>
    <InitialVehiclePlacement vehicleId="drone-x1" position="0,100,0" orientation="0,0,0,1" />
</Scene>

This XML defines how the WorldGenSystem generates the terrain, buildings (including their windows and interiors), and atmospheric properties, serving as a data asset for procedural generation [7, 10].
2. Example XML for a Component ()
This XML would define the specific parameters for a PropulsionUnitC instance, which is a vehicle-specific component [11, 12]. The VehicleCPUComponent would then use these parameters to command the propulsion unit, and the PhysicsSystem would calculate forces and torques based on them [11, 13, 14].
<!-- packages/vehicles/drone-x1/config/drone_x1_components.xml -->
<VehicleComponents vehicleType="DroneX1">
    <PropulsionUnit id="motor_fr" type="vertical_propeller">
        <LocationOffset x="0.15" y="0.0" z="0.15" /> <!-- Relative to CoM -->
        <ThrustAxis x="0" y="1" z="0" /> <!-- Upwards in body frame, assuming Y is up -->
        <ThrustCoefficient value="5.0e-5" /> <!-- kT -->
        <TorqueCoefficient value="5.0e-7" /> <!-- kQ -->
        <SpinDirection value="1" /> <!-- Clockwise -->
        <MotorResponseTimeConstant value="0.02" /> <!-- τ_motor -->
    </PropulsionUnit>
    <PropulsionUnit id="motor_fl" type="vertical_propeller">
        <LocationOffset x="-0.15" y="0.0" z="0.15" />
        <ThrustAxis x="0" y="1" z="0" />
        <ThrustCoefficient value="5.0e-5" />
        <TorqueCoefficient value="5.0e-7" />
        <SpinDirection value="-1" /> <!-- Counter-clockwise -->
        <MotorResponseTimeConstant value="0.02" />
    </PropulsionUnit>
    <!-- ... other motor definitions ... -->
    <Battery id="main_battery" capacity_Ah="5.0" internal_resistance_Ohm="0.015" />
    <Sensors>
        <IMU noise_gyro="0.001" noise_accel="0.01" sample_rate_Hz="200" />
        <GPS noise_pos="0.5" sample_rate_Hz="5" />
    </Sensors>
    <!-- ... other components like AerodynamicBodyC, LandingGearC ... -->
</VehicleComponents>

This XML snippet defines two propulsion units for a drone, including their physical properties like location_offset, thrust_axis, and kT/kQ coefficients. It also briefly shows definitions for Battery and Sensors components [11, 12, 14].
3. Example XML for a Parametric Asset ()
This XML defines a parametric furniture asset, as described in the worldgen.md source [15]. The WorldGenSystem can use this definition to procedurally generate and instance furniture within building interiors [7, 16].
<!-- packages/environment/world_gen/furniture/office_table_basic.xml -->
<FurnitureAsset id="office_table_basic" type="Table">
    <Parameters>
        <TopSize width="1.6" depth="0.8" />
        <TopThickness value="0.04" />
        <LegThickness value="0.05" />
        <Height value="0.75" />
    </Parameters>
    <Material>
        <Color r="0.4" g="0.3" b="0.2" a="1.0" />
        <Roughness value="0.8" />
    </Material>
    <PlacementRules>
        <ClearanceInset value="0.3" />
        <MinSpacing value="1.5" />
    </PlacementRules>
</FurnitureAsset>

This XML defines a table with specific dimensions and material properties. The WorldGenSystem would read these parameters and generate the appropriate geometry when populating a room [15].
Wiring to the Current C++ Code
The C++ architecture is built upon Inversion of Control (IoC) via Dependency Injection (DI), Entity-Component-System (ECS), and Event-Driven Communication [1, 17]. The integration of XML-defined assets and configurations into this C++ structure follows these principles:
1. XML Parsing and Data Loading:
    ◦ The C++ application, using its toolchain (MinGW-w64/aarch64-linux-gnu-g++, CMake) [18, 19], would include a dedicated XML parsing module (e.g., using a library like TinyXML2 or RapidXML, though not explicitly mentioned in sources, such a component would be standard).
    ◦ This module would be responsible for loading *.xml files from the packages/ and world_gen/ directories [7].
    ◦ The parsed XML data (e.g., scene parameters, component values, asset definitions) would be loaded into appropriate data structures (e.g., structs or classes representing SceneConfig, ComponentConfig, AssetParams).
2. ECS Integration (Entities and Components):
    ◦ The parsed component XML data (e.g., drone_x1_components.xml) would be consumed by an Entity Factory or Vehicle Spawner system.
    ◦ When an AerichalVehicle (an ECS entity) is created, the factory reads the XML configuration for that vehicle type [20]. It then instantiates the necessary Components (e.g., PropulsionUnitC, BatteryC, SensorsC, AerodynamicBodyC) and attaches them to the entity.
    ◦ Each component instance's internal data members (e.g., kT, kQ for PropulsionUnitC, capacity_Ah, internal_resistance_Ohm for BatteryC) are populated directly from the parsed XML values [11, 12, 14]. This ensures that the vehicle's behavior is dictated by its data configuration rather than hardcoded values.
3. IoC and Dependency Injection:
    ◦ Systems (e.g., PhysicsSystem, VehicleControlSystem, WorldGenSystem) rely on abstractions (interfaces) rather than concrete implementations [1].
    ◦ The IoC Container (or "Poor Man's DI" approach), primarily using constructor injection [17], would create and manage the lifecycle of these systems.
    ◦ For example, when PhysicsSystem is instantiated, it might receive references or pointers to IPropulsionUnit or IAerodynamicBody interfaces. The concrete PropulsionUnitC and AerodynamicBodyC instances (which were initialized with data from XML) would be injected into PhysicsSystem's constructor [9, 21, 22]. This allows the PhysicsSystem to perform its calculations using the specific parameters loaded from the XML, without needing to know how those parameters were defined.
    ◦ Similarly, the WorldGenSystem would be injected with the parsed SceneConfig data, enabling it to generate the environment according to the XML specifications [7, 9].
4. Asset Loading and Management:
    ◦ XML files can also define paths to external 3D models (e.g., .gltf [6]), textures (.png), shaders (.glsl), and sounds (.ogg).
    ◦ An AssetLoader component or service would read these paths from the XML. It would then use the appropriate underlying libraries (e.g., SDL2 for rendering on Windows, OpenGL ES for ARM64 if needed [19]) to load the raw asset data.
    ◦ These assets would then be made available to rendering systems (like the VisualizationSystem [23]) or audio systems, potentially after applying optimizations like Object Pooling, Spatial Partitioning, and Level of Detail (LOD) [1, 24, 25].
5. Event-Driven Communication:
    ◦ While XML defines static configurations, runtime changes or events (e.g., "BatteryLow", "HardImpact") can be published to the global EventBus [1, 26].
    ◦ Systems and components, configured by XML, can then subscribe to these events. For example, VehicleCPUComponent (configured by XML) might subscribe to a "BatteryLow" event to trigger a failsafe landing [11].
In essence, the XML files serve as the externalized configuration layer, providing the data that drives the behavior of the C++ systems and components. The C++ code provides the runtime logic and framework to parse this data, instantiate objects, inject dependencies, and execute the simulation, upholding the principles of modularity and extensibility [1, 5, 17]. This clear separation ensures that new vehicles, scenes, or component variations can be introduced or modified by updating XML files without altering the core C++ application logic [5].