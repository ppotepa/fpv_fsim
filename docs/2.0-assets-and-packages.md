2.0-assets-and-packages
Przewodnik po źródłach
This source outlines an architecture for a C++ vehicle simulation, emphasizing the crucial role of external configuration via XML files to achieve flexibility and modularity. It details how simulation elements like scene configurations, component parameters, and parametric assets are defined in XML, promoting a data-driven approach where new content can be added without altering core C++ code. The text explains how these XML definitions integrate with the C++ codebase using principles like Entity-Component-System (ECS) for object composition and Inversion of Control (IoC) via Dependency Injection (DI) for managing system dependencies. Ultimately, this separation allows XML files to act as the primary configuration layer, driving the simulation's behavior and enabling easy extensibility.











C++ Vehicle Simulation: Assets, Packages, and Configuration
For Chapter 2.0, focusing on assets and packages within the C++ vehicle simulation architecture, we will first establish an example directory tree, then provide illustrative XML files for a scene and components, and finally explain how these external configurations are integrated with the C++ codebase.
Example Tree for Packages and Assets
The simulation architecture, designed with Entity-Component-System (ECS) and mini-domain principles, leverages a modular file structure for assets and packages [1-4]. This allows for clear separation of concerns and supports the Open/Closed Principle (OCP), meaning new asset types can be added without modifying existing code [1, 5].
Below is an example directory tree illustrating how packages and assets might be organized:
// Project Root
├── packages/
│   ├── core/                  // Core infrastructure (ECS, EventBus, SimClock)
│   │   ├── src/
│   │   ├── include/
│   │   └── CMakeLists.txt
│   ├── physics/               // Physics domain (systems, components, integrators)
│   │   ├── src/
│   │   ├── include/
│   │   └── CMakeLists.txt
│   ├── vehicles/              // Vehicle definitions (drones, fixed-wing)
│   │   ├── drone-x1/          // Example drone package
│   │   │   ├── assets/
│   │   │   │   ├── models/
│   │   │   │   │   └── drone_x1.gltf
│   │   │   │   └── textures/
│   │   │   │       └── drone_x1_albedo.png
│   │   │   ├── config/
│   │   │   │   └── drone_x1_components.xml  // Component definitions for this drone
│   │   │   ├── src/
│   │   │   ├── include/
│   │   │   └── CMakeLists.txt
│   │   └── fixed-wing-alpha/  // Example fixed-wing aircraft package
│   │       ├── assets/
│   │       │   └── models/
│   │       │       └── fixed_wing_alpha.gltf
│   │       ├── config/
│   │       │   └── fixed_wing_alpha_components.xml
│   │       ├── src/
│   │       ├── include/
│   │       └── CMakeLists.txt
│   ├── environment/           // World generation assets and configurations
│   │   ├── world_gen/
│   │   │   ├── scenes/
│   │   │   │   └── city_day_scene.xml     // Scene definition
│   │   │   │   └── mountain_range_scene.xml
│   │   │   ├── furniture/                 // Parametric furniture assets
│   │   │   │   ├── table_office.xml
│   │   │   │   └── shelf_wall.xml
│   │   │   ├── textures/
│   │   │   │   └── terrain_grass_pbr.png
│   │   │   └── CMakeLists.txt
│   │   ├── assets/            // Generic environment assets
│   │   │   ├── models/
│   │   │   │   └── tree_pine_lod0.gltf
│   │   │   ├── textures/
│   │   │   │   └── water_normal.png
│   │   │   ├── sounds/
│   │   │   │   └── wind_ambient.ogg
│   │   │   └── shaders/
│   │   │       ├── terrain_shader.glsl
│   │   │       └── water_shader.glsl
│   │   └── CMakeLists.txt
│   └── ui/                    // User interface assets and configurations
│       ├── assets/
│       │   ├── sounds/
│       │   │   └── click.ogg
│       │   └── images/
│       │       └── hud_icon_battery.png
│       ├── config/
│       │   └── hud_layout_standard.xml    // HUD layout definition
│       │   └── menu_main.xml              // Main menu definition
│       ├── src/
│       ├── include/
│       └── CMakeLists.txt
└── CMakeLists.txt             // Main CMake for the entire project

This structure aligns with the concept of mini-domains (e.g., physics/, vehicles/, environment/) and allows for logical grouping of related code and assets [1]. Asset categories like models/, textures/, shaders/, and sounds/ are explicitly supported [6]. The use of config/ folders for XML definitions emphasizes data-driven configuration, which is crucial for extensibility [5, 7, 8].
Example XML Files for Scene and Components
XML files are used to define various aspects of the simulation, from scene configurations to component parameters and asset properties, promoting a data-driven approach [5, 7].
1. Example XML for a Scene ()
This XML would define the parameters for procedural generation of a city environment, which would be processed by the WorldGenSystem [7, 9]. It draws on concepts like procedural terrain, buildings with interiors, and wind models [10].
<!-- packages/environment/world_gen/scenes/city_day_scene.xml -->
<Scene name="CityDay" description="A sprawling urban landscape with dynamic weather.">
    <WorldGenerator>
        <Terrain type="ProceduralTerran">
            <Seed value="12345" />
            <HeightMapScale x="2000" z="2000" />
            <NoiseLayers>
                <Layer type="Perlin" frequency="0.005" amplitude="50" octaves="4" />
                <Layer type="Worley" frequency="0.02" amplitude="10" />
            </HeightMapScale>
            <Biome type="Urban" /> <!-- References a 'Biome' asset definition -->
        </Terrain>
        <BuildingsGeneration>
            <BuildingDensity min="0.3" max="0.7" />
            <AverageFloorHeight value="3.5" />
            <WindowConfiguration targetWindowWallRatio="0.35" minBaySpacing="2.5" maxBaySpacing="4.0" />
            <InteriorConfiguration enableInteriors="true" furnitureDensity="0.08">
                <FurnitureTemplates>
                    <FurnitureAsset ref="office_table_basic.xml" /> <!-- References parametric furniture asset -->
                    <FurnitureAsset ref="wall_shelf_standard.xml" />
                </FurnitureTemplates>
            </InteriorConfiguration>
        </BuildingsGeneration>
    </WorldGenerator>
    <EnvironmentalPhysics>
        <Gravity vector="0,-9.81,0" />
        <Atmosphere type="ISAStandard">
            <SeaLevelDensity value="1.225" />
            <ScaleHeight value="8500" />
        </Atmosphere>
        <WindModel type="AdvancedPerlin">
            <BaseWind vector="5,0,0" />
            <GustStrength value="10" frequency="0.1" decayTime="5.0" />
            <TurbulenceScale x="50" y="50" z="50" time="10" amplitude="1.0" />
            <BuildingTurbulence enable="true" />
        </WindModel>
    </EnvironmentalPhysics>
    <InitialVehiclePlacement vehicleId="drone-x1" position="0,100,0" orientation="0,0,0,1" />
</Scene>

This XML defines how the WorldGenSystem generates the terrain, buildings (including their windows and interiors), and atmospheric properties, serving as a data asset for procedural generation [7, 10].
2. Example XML for a Component ()
This XML would define the specific parameters for a PropulsionUnitC instance, which is a vehicle-specific component [11, 12]. The VehicleCPUComponent would then use these parameters to command the propulsion unit, and the PhysicsSystem would calculate forces and torques based on them [11, 13, 14].
<!-- packages/vehicles/drone-x1/config/drone_x1_components.xml -->
<VehicleComponents vehicleType="DroneX1">
    <PropulsionUnit id="motor_fr" type="vertical_propeller">
        <LocationOffset x="0.15" y="0.0" z="0.15" /> <!-- Relative to CoM -->
        <ThrustAxis x="0" y="1" z="0" /> <!-- Upwards in body frame, assuming Y is up -->
        <ThrustCoefficient value="5.0e-5" /> <!-- kT -->
        <TorqueCoefficient value="5.0e-7" /> <!-- kQ -->
        <SpinDirection value="1" /> <!-- Clockwise -->
        <MotorResponseTimeConstant value="0.02" /> <!-- τ_motor -->
    </PropulsionUnit>
    <PropulsionUnit id="motor_fl" type="vertical_propeller">
        <LocationOffset x="-0.15" y="0.0" z="0.15" />
        <ThrustAxis x="0" y="1" z="0" />
        <ThrustCoefficient value="5.0e-5" />
        <TorqueCoefficient value="5.0e-7" />
        <SpinDirection value="-1" /> <!-- Counter-clockwise -->
        <MotorResponseTimeConstant value="0.02" />
    </PropulsionUnit>
    <!-- ... other motor definitions ... -->
    <Battery id="main_battery" capacity_Ah="5.0" internal_resistance_Ohm="0.015" />
    <Sensors>
        <IMU noise_gyro="0.001" noise_accel="0.01" sample_rate_Hz="200" />
        <GPS noise_pos="0.5" sample_rate_Hz="5" />
    </Sensors>
    <!-- ... other components like AerodynamicBodyC, LandingGearC ... -->
</VehicleComponents>

This XML snippet defines two propulsion units for a drone, including their physical properties like location_offset, thrust_axis, and kT/kQ coefficients. It also briefly shows definitions for Battery and Sensors components [11, 12, 14].
3. Example XML for a Parametric Asset ()
This XML defines a parametric furniture asset, as described in the worldgen.md source [15]. The WorldGenSystem can use this definition to procedurally generate and instance furniture within building interiors [7, 16].
<!-- packages/environment/world_gen/furniture/office_table_basic.xml -->
<FurnitureAsset id="office_table_basic" type="Table">
    <Parameters>
        <TopSize width="1.6" depth="0.8" />
        <TopThickness value="0.04" />
        <LegThickness value="0.05" />
        <Height value="0.75" />
    </Parameters>
    <Material>
        <Color r="0.4" g="0.3" b="0.2" a="1.0" />
        <Roughness value="0.8" />
    </Material>
    <PlacementRules>
        <ClearanceInset value="0.3" />
        <MinSpacing value="1.5" />
    </PlacementRules>
</FurnitureAsset>

This XML defines a table with specific dimensions and material properties. The WorldGenSystem would read these parameters and generate the appropriate geometry when populating a room [15].
Wiring to the Current C++ Code
The C++ architecture is built upon Inversion of Control (IoC) via Dependency Injection (DI), Entity-Component-System (ECS), and Event-Driven Communication [1, 17]. The integration of XML-defined assets and configurations into this C++ structure follows these principles:
1. XML Parsing and Data Loading:
    ◦ The C++ application, using its toolchain (MinGW-w64/aarch64-linux-gnu-g++, CMake) [18, 19], would include a dedicated XML parsing module (e.g., using a library like TinyXML2 or RapidXML, though not explicitly mentioned in sources, such a component would be standard).
    ◦ This module would be responsible for loading *.xml files from the packages/ and world_gen/ directories [7].
    ◦ The parsed XML data (e.g., scene parameters, component values, asset definitions) would be loaded into appropriate data structures (e.g., structs or classes representing SceneConfig, ComponentConfig, AssetParams).
2. ECS Integration (Entities and Components):
    ◦ The parsed component XML data (e.g., drone_x1_components.xml) would be consumed by an Entity Factory or Vehicle Spawner system.
    ◦ When an AerichalVehicle (an ECS entity) is created, the factory reads the XML configuration for that vehicle type [20]. It then instantiates the necessary Components (e.g., PropulsionUnitC, BatteryC, SensorsC, AerodynamicBodyC) and attaches them to the entity.
    ◦ Each component instance's internal data members (e.g., kT, kQ for PropulsionUnitC, capacity_Ah, internal_resistance_Ohm for BatteryC) are populated directly from the parsed XML values [11, 12, 14]. This ensures that the vehicle's behavior is dictated by its data configuration rather than hardcoded values.
3. IoC and Dependency Injection:
    ◦ Systems (e.g., PhysicsSystem, VehicleControlSystem, WorldGenSystem) rely on abstractions (interfaces) rather than concrete implementations [1].
    ◦ The IoC Container (or "Poor Man's DI" approach), primarily using constructor injection [17], would create and manage the lifecycle of these systems.
    ◦ For example, when PhysicsSystem is instantiated, it might receive references or pointers to IPropulsionUnit or IAerodynamicBody interfaces. The concrete PropulsionUnitC and AerodynamicBodyC instances (which were initialized with data from XML) would be injected into PhysicsSystem's constructor [9, 21, 22]. This allows the PhysicsSystem to perform its calculations using the specific parameters loaded from the XML, without needing to know how those parameters were defined.
    ◦ Similarly, the WorldGenSystem would be injected with the parsed SceneConfig data, enabling it to generate the environment according to the XML specifications [7, 9].
4. Asset Loading and Management:
    ◦ XML files can also define paths to external 3D models (e.g., .gltf [6]), textures (.png), shaders (.glsl), and sounds (.ogg).
    ◦ An AssetLoader component or service would read these paths from the XML. It would then use the appropriate underlying libraries (e.g., SDL2 for rendering on Windows, OpenGL ES for ARM64 if needed [19]) to load the raw asset data.
    ◦ These assets would then be made available to rendering systems (like the VisualizationSystem [23]) or audio systems, potentially after applying optimizations like Object Pooling, Spatial Partitioning, and Level of Detail (LOD) [1, 24, 25].
5. Event-Driven Communication:
    ◦ While XML defines static configurations, runtime changes or events (e.g., "BatteryLow", "HardImpact") can be published to the global EventBus [1, 26].
    ◦ Systems and components, configured by XML, can then subscribe to these events. For example, VehicleCPUComponent (configured by XML) might subscribe to a "BatteryLow" event to trigger a failsafe landing [11].
In essence, the XML files serve as the externalized configuration layer, providing the data that drives the behavior of the C++ systems and components. The C++ code provides the runtime logic and framework to parse this data, instantiate objects, inject dependencies, and execute the simulation, upholding the principles of modularity and extensibility [1, 5, 17]. This clear separation ensures that new vehicles, scenes, or component variations can be introduced or modified by updating XML files without altering the core C++ application logic [5].