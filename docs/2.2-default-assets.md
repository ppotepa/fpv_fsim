Here's a developer package structure and implementation plan for integrating a debug console, a default sphere world scene, and the requested "Earth-like" features, all designed to fit within the established C++ vehicle simulation architecture.

---

### **Developer Package: Assets, Console, and `main.cpp` Integration**

This developer package focuses on enhancing the simulation's usability with a debug console and providing a robust default scene when no other assets are available. It adheres to the project's principles of modularity, ECS, and IoC.

#### **1. Project Structure for the Developer Package:**

The proposed structure integrates new elements into the existing mini-domain architecture:

```
/
├── assets/
│   ├── packages/                     # Empty if no user-defined packages are found
│   │   └── (user_packages.xml)
│   └── console/                      # New: Assets for the developer console UI (fonts, basic textures)
│       └── console_font.ttf
│       └── console_background.png
│
├── build_tools/
│   └── (existing asset compiler, codegen)
│
├── runtime/
│   ├── data/
│   │   ├── packs/                    # Empty if no packages are found
│   │   └── plugins/
│   │   └── cache/
│   └── (runtime libraries)
│
├── systems/
│   ├── BootstrapSystem.hpp/.cpp      # Modified for package check & default scene init
│   ├── InputSystem.hpp/.cpp          # Modified to detect tilde (~) key
│   ├── WorldGenSystem.hpp/.cpp       # Modified to generate default sphere world
│   ├── VisualizationSystem.hpp/.cpp  # Modified to render console & "no packages found" message
│   └── ConsoleSystem.hpp/.cpp        # New: Manages console state, commands, UI
│
├── components/
│   └── DebugC.hpp/.cpp               # Potentially updated to manage console visibility/state
│
├── events/
│   ├── InputEvents.hpp               # New: Defines ConsoleToggleEvent
│   └── WorldGenEvents.hpp            # New: Defines DefaultWorldGeneratedEvent
│
└── main.cpp                          # Modified: Entry point, initializes core systems
```

#### **2. Dev Console: Toggled by Tilde (~)**

A new `ConsoleSystem` will manage the developer console, integrated via the `InputSystem` and `VisualizationSystem`.

*   **`InputSystem` (Modification):**
    *   The `InputSystem` is responsible for gathering raw user inputs from devices like keyboards and gamepads. It will be modified to detect the tilde (`) key press.
    *   Upon detection, it will publish a `ConsoleToggleEvent` to the global `EventBus`. This adheres to the event-driven communication principle, ensuring loose coupling.

    **Code Example (`InputSystem::Tick()`):**
    ```cpp
    // In InputSystem.hpp
    #include "events/InputEvents.hpp"
    // ...

    // In InputSystem.cpp
    void InputSystem::Tick(float dt) {
        // ... (Existing gamepad/keyboard input processing)

        if (keyboard.isKeyPressed(KeyCode::Tilde)) { // Assuming KeyCode::Tilde exists
            eventBus.emit(ConsoleToggleEvent{});
        }

        // ...
    }
    ```

*   **`ConsoleSystem` (New System):**
    *   This system will subscribe to `ConsoleToggleEvent` from the `EventBus`.
    *   It will manage the console's state (open/closed) and process commands entered by the user. Commands could interact with other systems via the IoC container or by publishing events.
    *   Its `onToggle` method would simply flip a boolean `isVisible` flag.

    **Code Example (`ConsoleSystem::ConsoleSystem()`):**
    ```cpp
    // In ConsoleSystem.hpp
    class ConsoleSystem {
    public:
        ConsoleSystem(EventBus& eventBus, IContainer& iocContainer); // IoC for command execution
        void Init();
        void Tick(float dt);
        bool IsVisible() const { return isVisible; }

    private:
        EventBus& eventBus;
        IContainer& iocContainer;
        bool isVisible = false;

        void OnConsoleToggle(const ConsoleToggleEvent& event);
        void ProcessCommand(const std::string& command);
        // ... other console logic
    };

    // In ConsoleSystem.cpp
    ConsoleSystem::ConsoleSystem(EventBus& eventBus, IContainer& iocContainer)
        : eventBus(eventBus), iocContainer(iocContainer)
    {
        eventBus.subscribe<ConsoleToggleEvent>(
            std::bind(&ConsoleSystem::OnConsoleToggle, this, std::placeholders::_1));
    }

    void ConsoleSystem::OnConsoleToggle(const ConsoleToggleEvent& event) {
        isVisible = !isVisible;
        // Optionally emit an event for VisualizationSystem to react immediately
        eventBus.emit(ConsoleVisibilityChangedEvent{isVisible});
    }
    // ... command processing, rendering (via VisualizationSystem)
    ```

*   **`VisualizationSystem` (Modification):**
    *   The `VisualizationSystem` is responsible for rendering the 3D scene, HUD, and debug overlays. It will be extended to render the `ConsoleSystem`'s UI when it is visible.
    *   It would query the `ConsoleSystem`'s `IsVisible()` state or subscribe to a `ConsoleVisibilityChangedEvent`.

    **Code Example (`VisualizationSystem::Render()`):**
    ```cpp
    // In VisualizationSystem.cpp
    #include "systems/ConsoleSystem.hpp"
    // ...

    void VisualizationSystem::Render() {
        // ... render 3D scene, HUD

        // Assuming ConsoleSystem is accessible, e.g., via IoC or direct reference
        ConsoleSystem& console = iocContainer.get<ConsoleSystem>();
        if (console.IsVisible()) {
            // Render console background, text input, output buffer
            // Use assets from /assets/console/ (e.g., console_font.ttf) [user query]
            // This would involve low-level rendering calls (SDL2/OpenGL ES)
            renderConsoleUI(console.GetInputBuffer(), console.GetOutputLog());
        }

        // ...
    }
    ```

#### **3. Default Sphere World Scene & "No Packages Found"**

The simulation will fall back to a default "Earth-like" sphere world if no asset packages are loaded.

*   **`main.cpp` (Modification):**
    *   The `main.cpp` entry point orchestrates the `BootstrapSystem`.

    **Code Example (`main.cpp`):**
    ```cpp
    // In main.cpp
    int main() {
        // ... (Initialize core IoC container, EventBus, etc.)

        BootstrapSystem bootstrap(eventBus, iocContainer);
        bootstrap.Init(); // This will handle package loading and default scene fallback

        // Main simulation loop
        while (isRunning) {
            // ... (Tick InputSystem, VehicleControlSystem, PhysicsSystem, etc.)
            bootstrap.PostFrameUpdate(); // Handles hot-reloading if active
        }
        // ...
        return 0;
    }
    ```

*   **`BootstrapSystem` (Modification):**
    *   This one-shot system, executed at startup, is responsible for loading core packs and constructing the initial world. It will be modified to check for loaded packages.
    *   It would use the `AssetPackLoader` to attempt loading `.pak` files. If no packs are successfully loaded (e.g., `/runtime/data/packs/` is empty or `assets/packages/package.xml` files are missing/invalid), it will trigger the default scene creation in `WorldGenSystem`.

    **Code Example (`BootstrapSystem::Init()`):**
    ```cpp
    // In BootstrapSystem.hpp
    #include "systems/WorldGenSystem.hpp"
    #include "asset_management/AssetPackLoader.hpp" // Assuming this exists
    #include "asset_management/AssetRegistry.hpp"   // Assuming this exists
    #include "events/WorldGenEvents.hpp"
    // ...

    // In BootstrapSystem.cpp
    void BootstrapSystem::Init() {
        // ... (Build root IoC container, load core services)

        AssetPackLoader& packLoader = iocContainer.get<AssetPackLoader>();
        AssetRegistry& assetRegistry = iocContainer.get<AssetRegistry>();

        // Attempt to load packages (e.g., from runtime/data/packs or assets/packages/*.xml)
        packLoader.LoadAllPacks(); // This would populate AssetRegistry if successful

        if (assetRegistry.IsEmpty()) { // Check if any assets were successfully loaded
            WorldGenSystem& worldGen = iocContainer.get<WorldGenSystem>();
            worldGen.GenerateDefaultSphereWorld(); [user query]
            eventBus.emit(NoPackagesFoundEvent{}); // Notify VisualizationSystem
        } else {
            // Proceed with loading specified world/scene from loaded assets
            // ...
        }

        // ... (Initialize plugins, construct world based on loaded/default scene)
    }
    ```

*   **`WorldGenSystem` (Modification for Default Sphere World):**
    *   The `WorldGenSystem` manages procedural generation of the world. It will gain a `GenerateDefaultSphereWorld()` method.
    *   This method will procedurally create the "Earth-like" sphere, its atmospheric layers, and voxel clouds.
    *   It would define a fixed `SceneConfig` internally for this default world, rather than parsing it from XML.

    **Code Example (`WorldGenSystem::GenerateDefaultSphereWorld()`):**
    ```cpp
    // In WorldGenSystem.hpp
    #include "components/TransformC.hpp" // For placing entities
    #include "components/RenderableC.hpp" // For visual representation
    // ...

    // In WorldGenSystem.cpp
    void WorldGenSystem::GenerateDefaultSphereWorld() { [user query]
        // 1. Create the "Earth" sphere entity
        Entity earthEntity = world.CreateEntity(); // ECS entity
        world.AddComponent<TransformC>(earthEntity, {
            .position = {0, -6371000, 0}, // Place Earth at appropriate Y-offset (radius approx)
            .orientation = Quaternion::Identity()
        });
        world.AddComponent<RenderableC>(earthEntity, {
            .meshId = GenerateProceduralSphereMesh(6371000, 64), // Radius, segments
            .materialId = GetEarthMaterialId() // Placeholder: Would need a baked Earth texture
        });

        // 2. Create "Spherical Layers" (Atmosphere) [user query]
        // Example: Two layers
        for (int i = 0; i < 2; ++i) {
            Entity atmosphereLayer = world.CreateEntity();
            float layerRadius = 6371000 + 10000.0f * (i + 1); // e.g., 10km, 20km above surface
            world.AddComponent<TransformC>(atmosphereLayer, {
                .position = {0, -6371000, 0},
                .orientation = Quaternion::Identity()
            });
            world.AddComponent<RenderableC>(atmosphereLayer, {
                .meshId = GenerateProceduralSphereMesh(layerRadius, 32),
                .materialId = GetAtmosphereMaterialId(i) // Translucent materials
            });
            // These would simulate air density based on altitude
            // PhysicsSystem would query WorldGenSystem for rho(z)
        }

        // 3. Create "Voxel Clouds" orbiting [user query]
        // This could be a collection of particle systems or sparse voxel geometry
        Entity cloudEntity = world.CreateEntity();
        world.AddComponent<TransformC>(cloudEntity, {
            .position = {0, -6371000, 0}, // Centered with Earth
            .orientation = Quaternion::Identity()
        });
        world.AddComponent<RenderableC>(cloudEntity, {
            .meshId = GenerateProceduralVoxelClouds(6371000 + 5000, 5000, NoiseType::Perlin), // Radius, height range, noise
            .materialId = GetCloudMaterialId()
        });

        // Configure environmental physics for Earth
        // This assumes PhysicsSystem can query WorldGenSystem for these
        world.GetPhysicsSystem().SetGravity({0, -9.81, 0});
        world.GetPhysicsSystem().SetAirDensityModel(AirDensityModel::ExponentialISA);
        world.GetPhysicsSystem().SetBaseWind({10.0f, 0.0f, 0.0f}); // Example constant wind

        // Emit an event to signal world generation is complete
        eventBus.emit(DefaultWorldGeneratedEvent{});
    }

    // Helper to get AssetIds for default materials (could be baked or hardcoded)
    AssetId WorldGenSystem::GetEarthMaterialId() {
        // Return a pre-defined ID for a simple Earth texture
        return EarthMaterialAssetId;
    }
    AssetId WorldGenSystem::GetAtmosphereMaterialId(int layer) {
        return AtmosphereMaterialAssetId_L[layer];
    }
    AssetId WorldGenSystem::GetCloudMaterialId() {
        return CloudMaterialAssetId;
    }

    // Example for procedural mesh generation (simplified)
    AssetId WorldGenSystem::GenerateProceduralSphereMesh(float radius, int segments) {
        // Implement logic to generate sphere vertex/index data, store it,
        // and register with AssetRegistry if it's a runtime-generated mesh.
        // For release, this could be a 'semi-cooked' recipe.
        // For debug, it's live-built.
        return GenerateMeshFromRecipe(SphereRecipe{radius, segments});
    }

    AssetId WorldGenSystem::GenerateProceduralVoxelClouds(float baseRadius, float heightRange, NoiseType noise) {
        // Implement complex procedural generation for clouds using noise functions
        // This would involve generating volume textures or particle positions.
        return GenerateMeshFromRecipe(CloudRecipe{baseRadius, heightRange, noise});
    }
    ```

*   **`VisualizationSystem` (Modification for "No Packages Found" Message):**
    *   This system will subscribe to the `NoPackagesFoundEvent`.
    *   When this event is received, it will activate an overlay displaying the message.

    **Code Example (`VisualizationSystem::Render()` and `OnNoPackagesFound()`):**
    ```cpp
    // In VisualizationSystem.hpp
    #include "events/WorldGenEvents.hpp"
    // ...
    class VisualizationSystem {
        // ...
        bool displayNoPackagesMessage = false;
        void OnNoPackagesFound(const NoPackagesFoundEvent& event);
    };

    // In VisualizationSystem.cpp
    VisualizationSystem::VisualizationSystem(EventBus& eventBus, IContainer& iocContainer)
        : eventBus(eventBus), iocContainer(iocContainer)
    {
        eventBus.subscribe<NoPackagesFoundEvent>(
            std::bind(&VisualizationSystem::OnNoPackagesFound, this, std::placeholders::_1));
        // ... subscribe to ConsoleVisibilityChangedEvent if needed for console rendering
    }

    void VisualizationSystem::OnNoPackagesFound(const NoPackagesFoundEvent& event) {
        displayNoPackagesMessage = true; [user query]
    }

    void VisualizationSystem::Render() {
        // ... render 3D scene, HUD

        if (displayNoPackagesMessage) {
            // Render "No packages found" text overlay [user query]
            // e.g., using SDL2_ttf for text rendering
            drawText("No packages found. Displaying default sphere world.", ScreenCenter, WhiteColor);
        }

        // ... Render console UI if visible [user query]
    }
    ```

#### **4. Summary of Affected Files:**

*   **`main.cpp`**: Orchestrates `BootstrapSystem` and main loop.
*   **`systems/BootstrapSystem.hpp`/`.cpp`**: Initializes the world, checks for existing asset packages, and triggers default scene generation if none are found.
*   **`systems/InputSystem.hpp`/`.cpp`**: Detects tilde (~) key press and emits `ConsoleToggleEvent`.
*   **`systems/ConsoleSystem.hpp`/`.cpp` (NEW)**: Manages console state, command processing, and subscribes to `ConsoleToggleEvent`.
*   **`systems/WorldGenSystem.hpp`/`.cpp`**: Contains the `GenerateDefaultSphereWorld()` method, which creates the Earth-like sphere, layers, and voxel clouds.
*   **`systems/VisualizationSystem.hpp`/`.cpp`**: Renders the console UI when active and displays the "No packages found" message.
*   **`components/DebugC.hpp`/`.cpp`**: Might be updated to hold global debug flags, including console visibility.
*   **`events/InputEvents.hpp`**: Defines `ConsoleToggleEvent` for input system to console communication.
*   **`events/WorldGenEvents.hpp`**: Defines `NoPackagesFoundEvent` and `DefaultWorldGeneratedEvent`.
*   **`assets/console/` (NEW directory)**: Will contain fonts and basic textures for rendering the console UI.
*   **`asset_management/AssetPackLoader.hpp`/`.cpp` and `AssetRegistry.hpp`/`.cpp`**: Implicitly affected as `BootstrapSystem` queries them to determine if packages are present.

This comprehensive setup ensures that the developer console and a visually compelling default scene are available, enhancing the development experience and providing a functional fallback for the simulation.