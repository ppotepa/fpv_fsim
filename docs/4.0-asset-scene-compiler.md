# 4.0 Enhanced Asset-Scene Compiler Architecture

## Overview

The Enhanced Asset-Scene Compiler transforms the package-based XML architecture into optimized runtime representations while supporting hot-reload during development. This system bridges declarative scene authoring with high-performance execution through a sophisticated compilation pipeline that processes assets, scenes, and code-behind behaviors.

## 4.0.1 Core Architectural Principles

### Design Philosophy

The compiler architecture adheres to foundational principles that ensure optimal performance while maintaining development flexibility:

**Dual-Mode Operation:** The system operates in two distinct modes sharing a unified codebase:
- **Development Mode:** Raw XML with live compilation and hot-reload capabilities
- **Production Mode:** Pre-compiled binary packages with optimized loading

**Asset Identity Management:** All runtime operations use stable numeric IDs (`AssetId`, `SceneId`, `EntityId`) rather than string lookups, ensuring ultra-fast asset resolution and memory efficiency.

**Deterministic Updates:** All hot-reload changes are batched and committed at frame boundaries, maintaining simulation determinism and avoiding mid-frame state corruption.

**Separation of Concerns:** Complex processing (validation, optimization, compression) occurs at compile-time through dedicated build tools, keeping runtime systems focused on efficient loading and execution.

### Enhanced Package Structure

```
/
├── packages/
│   ├── core/                             # Core engine assets and behaviors
│   │   ├── package.xml                   # Core package definition
│   │   ├── assets/
│   │   │   ├── shaders/                  # Standard shaders (PBR, unlit, etc.)
│   │   │   ├── materials/                # Default materials
│   │   │   └── meshes/                   # Primitive meshes (cube, sphere, etc.)
│   │   └── behaviors/                    # Core behavior implementations
│   │       ├── Transform.cpp
│   │       ├── CameraController.cpp
│   │       └── PhysicsBody.cpp
│   ├── environment/                      # Environmental assets
│   │   ├── package.xml
│   │   ├── assets/
│   │   │   ├── terrain/                  # Terrain assets and heightmaps
│   │   │   ├── weather/                  # Weather system assets
│   │   │   └── lighting/                 # Lighting and atmosphere
│   │   └── behaviors/
│   │       ├── WeatherSystem.cpp
│   │       ├── TimeOfDay.cpp
│   │       └── WindSystem.cpp
│   ├── vehicles/                         # Vehicle-specific packages
│   │   ├── package.xml
│   │   ├── assets/
│   │   │   ├── models/                   # 3D vehicle models
│   │   │   ├── textures/                 # Vehicle textures and liveries
│   │   │   └── audio/                    # Engine sounds, etc.
│   │   └── behaviors/
│   │       ├── QuadcopterController.cpp
│   │       ├── FlightDynamics.cpp
│   │       └── AutoPilot.cpp
│   └── developer/                        # Development and testing package
│       ├── package.xml
│       ├── assets/
│       │   ├── debug/                    # Debug visualization assets
│       │   ├── test/                     # Test assets and scenes
│       │   └── tools/                    # Development tools
│       └── behaviors/
│           ├── DebugCamera.cpp
│           ├── PerformanceMonitor.cpp
│           └── SceneValidator.cpp
├── runtime/
│   ├── data/
│   │   ├── compiled/                     # Compiled binary assets
│   │   │   ├── core.pak                  # Compiled core package
│   │   │   ├── environment.pak           # Compiled environment package
│   │   │   ├── vehicles.pak              # Compiled vehicle package
│   │   │   └── developer.pak             # Compiled developer package
│   │   ├── cache/                        # Development hot-reload cache
│   │   │   ├── asset_cache/              # Cached compiled assets
│   │   │   ├── scene_cache/              # Cached compiled scenes
│   │   │   └── behavior_cache/           # Cached behavior metadata
│   │   └── generated/                    # Auto-generated code
│   │       ├── AssetIds.h                # Generated asset ID constants
│   │       ├── BehaviorRegistry.cpp      # Generated behavior registration
│   │       └── PackageManifest.cpp       # Generated package metadata
└── build_tools/
    ├── package_compiler/                 # Main package compilation tool
    │   ├── src/
    │   │   ├── PackageCompiler.cpp       # Core compilation logic
    │   │   ├── AssetProcessor.cpp        # Asset-specific processing
    │   │   ├── SceneCompiler.cpp         # Scene compilation
    │   │   └── BehaviorLinker.cpp        # Behavior code linking
    │   └── CMakeLists.txt
    ├── hot_reload_server/                # Development hot-reload server
    │   ├── src/
    │   │   ├── FileWatcher.cpp           # File system monitoring
    │   │   ├── ReloadServer.cpp          # Hot-reload coordination
    │   │   └── ChangeDetector.cpp        # Change detection and batching
    │   └── CMakeLists.txt
    ├── asset_validator/                  # Asset validation and testing
    │   ├── src/
    │   │   ├── PackageValidator.cpp      # Package structure validation
    │   │   ├── AssetValidator.cpp        # Individual asset validation
    │   │   └── ReferenceChecker.cpp      # Cross-reference validation
    │   └── CMakeLists.txt
    └── code_generator/                   # Code generation utilities
        ├── src/
        │   ├── IdGenerator.cpp           # Asset ID generation
        │   ├── RegistryGenerator.cpp     # Behavior registry generation
        │   └── ManifestGenerator.cpp     # Package manifest generation
        └── CMakeLists.txt
```

## 4.0.2 Compilation Pipeline Architecture

### Package Discovery and Parsing

#### Package Discovery Process
```cpp
class PackageDiscovery {
public:
    struct DiscoveryResult {
        std::vector<PackageManifest> packages;
        DependencyGraph dependencies;
        std::vector<std::string> errors;
    };
    
    DiscoveryResult discoverPackages(const std::string& packagesRoot) {
        DiscoveryResult result;
        
        // Scan for package.xml files
        auto packagePaths = findPackageFiles(packagesRoot);
        
        for (const auto& packagePath : packagePaths) {
            try {
                auto manifest = parsePackageManifest(packagePath);
                result.packages.push_back(manifest);
                
                // Build dependency graph
                for (const auto& dependency : manifest.dependencies) {
                    result.dependencies.addEdge(manifest.id, dependency.packageId);
                }
            } catch (const std::exception& e) {
                result.errors.push_back("Failed to parse package: " + packagePath + 
                                       " - " + e.what());
            }
        }
        
        // Validate dependency graph (check for cycles)
        if (!result.dependencies.isAcyclic()) {
            result.errors.push_back("Circular dependency detected in package graph");
        }
        
        return result;
    }

private:
    PackageManifest parsePackageManifest(const std::string& packagePath) {
        auto xmlDoc = XmlParser::parseFile(packagePath);
        
        PackageManifest manifest;
        manifest.id = xmlDoc.getAttribute("id");
        manifest.name = xmlDoc.getAttribute("name");
        manifest.version = xmlDoc.getAttribute("version");
        manifest.sourcePath = packagePath;
        
        // Parse dependencies
        auto depNodes = xmlDoc.selectNodes("//dependencies/dependency");
        for (auto& depNode : depNodes) {
            PackageDependency dep;
            dep.packageId = depNode.getAttribute("package");
            dep.version = depNode.getAttribute("version");
            dep.required = depNode.getAttribute("required", "true") == "true";
            manifest.dependencies.push_back(dep);
        }
        
        // Parse asset manifest
        parseAssetManifest(xmlDoc, manifest);
        
        // Parse scene manifest
        parseSceneManifest(xmlDoc, manifest);
        
        return manifest;
    }
};
```

### Asset Compilation System

#### Core Asset Compiler
```cpp
class AssetCompiler {
public:
    struct CompilationOptions {
        bool developmentMode = false;
        bool enableOptimization = true;
        bool generateDebugInfo = false;
        bool enableHotReload = false;
        std::string outputDirectory;
        std::string cacheDirectory;
    };
    
    struct CompilationResult {
        bool success;
        std::vector<CompiledAsset> assets;
        std::vector<CompiledScene> scenes;
        std::vector<std::string> errors;
        std::vector<std::string> warnings;
        CompilationStats stats;
    };
    
    CompilationResult compilePackage(const PackageManifest& package, 
                                   const CompilationOptions& options) {
        CompilationResult result;
        CompilationContext context(package, options);
        
        try {
            // Initialize compilation context
            initializeContext(context);
            
            // Compile assets in dependency order
            auto assetOrder = computeAssetCompilationOrder(package);
            for (const auto& assetId : assetOrder) {
                auto asset = package.findAsset(assetId);
                if (asset) {
                    auto compiledAsset = compileAsset(*asset, context);
                    if (compiledAsset.has_value()) {
                        result.assets.push_back(compiledAsset.value());
                    } else {
                        result.errors.push_back("Failed to compile asset: " + assetId);
                    }
                }
            }
            
            // Compile scenes
            for (const auto& scene : package.scenes) {
                auto compiledScene = compileScene(scene, context);
                if (compiledScene.has_value()) {
                    result.scenes.push_back(compiledScene.value());
                } else {
                    result.errors.push_back("Failed to compile scene: " + scene.id);
                }
            }
            
            // Generate package binary
            if (result.errors.empty()) {
                generatePackageBinary(result, context);
            }
            
            result.success = result.errors.empty();
            result.stats = context.getStats();
            
        } catch (const std::exception& e) {
            result.errors.push_back("Compilation failed: " + std::string(e.what()));
            result.success = false;
        }
        
        return result;
    }

private:
    std::optional<CompiledAsset> compileAsset(const Asset& asset, 
                                            CompilationContext& context) {
        // Check cache first
        if (context.options.enableHotReload) {
            auto cached = context.cache.getAsset(asset.id, asset.sourceHash);
            if (cached.has_value()) {
                context.stats.cacheHits++;
                return cached;
            }
        }
        
        CompiledAsset compiled;
        compiled.id = generateAssetId(asset.id, context);
        compiled.type = asset.type;
        compiled.sourceHash = asset.sourceHash;
        
        switch (asset.type) {
            case AssetType::Material:
                return compileMaterial(asset, context);
            case AssetType::Mesh:
                return compileMesh(asset, context);
            case AssetType::Texture:
                return compileTexture(asset, context);
            case AssetType::Shader:
                return compileShader(asset, context);
            case AssetType::Audio:
                return compileAudio(asset, context);
            default:
                context.addError("Unknown asset type for asset: " + asset.id);
                return std::nullopt;
        }
    }
    
    std::optional<CompiledAsset> compileMaterial(const Asset& asset, 
                                               CompilationContext& context) {
        auto materialData = std::get<MaterialAssetData>(asset.data);
        
        CompiledAsset compiled;
        compiled.id = generateAssetId(asset.id, context);
        compiled.type = AssetType::Material;
        
        // Resolve shader references
        auto shaderAsset = context.resolveAssetReference(materialData.shaderRef);
        if (!shaderAsset.has_value()) {
            context.addError("Material " + asset.id + " references unknown shader: " + 
                           materialData.shaderRef);
            return std::nullopt;
        }
        
        compiled.dependencies.push_back(shaderAsset.value());
        
        // Resolve texture references
        for (const auto& textureRef : materialData.textureRefs) {
            auto textureAsset = context.resolveAssetReference(textureRef.second);
            if (textureAsset.has_value()) {
                compiled.dependencies.push_back(textureAsset.value());
            } else if (textureRef.second != "default") {
                context.addWarning("Material " + asset.id + 
                                 " references unknown texture: " + textureRef.second);
            }
        }
        
        // Serialize material properties
        BinaryWriter writer;
        writer.writeUInt32(static_cast<uint32_t>(shaderAsset.value()));
        writer.writeUInt32(static_cast<uint32_t>(materialData.properties.size()));
        
        for (const auto& prop : materialData.properties) {
            writer.writeString(prop.first);
            serializeProperty(writer, prop.second);
        }
        
        compiled.binaryData = writer.getData();
        compiled.dataSize = compiled.binaryData.size();
        
        // Cache compiled asset
        if (context.options.enableHotReload) {
            context.cache.storeAsset(compiled);
        }
        
        context.stats.compiledAssets++;
        return compiled;
    }
    
    std::optional<CompiledAsset> compileMesh(const Asset& asset, 
                                           CompilationContext& context) {
        auto meshData = std::get<MeshAssetData>(asset.data);
        
        // Load source mesh file
        auto sourceMesh = MeshLoader::loadMesh(meshData.sourcePath);
        if (!sourceMesh.has_value()) {
            context.addError("Failed to load mesh source: " + meshData.sourcePath);
            return std::nullopt;
        }
        
        // Apply optimizations
        if (context.options.enableOptimization) {
            sourceMesh = MeshOptimizer::optimize(sourceMesh.value(), 
                                               meshData.optimizationLevel);
        }
        
        // Generate tangents if requested
        if (meshData.generateTangents) {
            MeshProcessor::generateTangents(sourceMesh.value());
        }
        
        CompiledAsset compiled;
        compiled.id = generateAssetId(asset.id, context);
        compiled.type = AssetType::Mesh;
        
        // Serialize mesh data
        BinaryWriter writer;
        serializeMesh(writer, sourceMesh.value());
        
        compiled.binaryData = writer.getData();
        compiled.dataSize = compiled.binaryData.size();
        
        // Cache compiled asset
        if (context.options.enableHotReload) {
            context.cache.storeAsset(compiled);
        }
        
        context.stats.compiledAssets++;
        context.stats.totalVertices += sourceMesh.value().vertices.size();
        context.stats.totalTriangles += sourceMesh.value().indices.size() / 3;
        
        return compiled;
    }
};
```

### Scene Compilation System

#### Scene Compiler Implementation
```cpp
class SceneCompiler {
public:
    std::optional<CompiledScene> compileScene(const Scene& scene, 
                                            CompilationContext& context) {
        CompiledScene compiled;
        compiled.id = generateSceneId(scene.id, context);
        compiled.name = scene.name;
        compiled.entityCount = scene.entities.size();
        
        // Compile entities
        for (const auto& entity : scene.entities) {
            auto compiledEntity = compileEntity(entity, context);
            if (compiledEntity.has_value()) {
                compiled.entities.push_back(compiledEntity.value());
            } else {
                context.addError("Failed to compile entity: " + entity.id + 
                               " in scene: " + scene.id);
                return std::nullopt;
            }
        }
        
        // Pack component data
        compiled.componentDataBlob = packComponentData(compiled.entities);
        
        // Generate scene binary
        BinaryWriter writer;
        serializeScene(writer, compiled);
        compiled.binaryData = writer.getData();
        
        context.stats.compiledScenes++;
        context.stats.totalEntities += compiled.entities.size();
        
        return compiled;
    }

private:
    std::optional<CompiledEntity> compileEntity(const Entity& entity, 
                                              CompilationContext& context) {
        CompiledEntity compiled;
        compiled.id = generateEntityId(entity.id, context);
        compiled.name = entity.name;
        compiled.initialTransform = entity.transform;
        
        // Compile components
        ComponentMask componentMask = 0;
        std::vector<uint8_t> componentData;
        
        for (const auto& component : entity.components) {
            auto compiledComponent = compileComponent(component, context);
            if (compiledComponent.has_value()) {
                componentMask |= getComponentMask(component.type);
                
                // Append component data
                auto& compData = compiledComponent.value();
                componentData.insert(componentData.end(), 
                                   compData.begin(), compData.end());
            } else {
                context.addError("Failed to compile component for entity: " + entity.id);
                return std::nullopt;
            }
        }
        
        compiled.componentMask = componentMask;
        compiled.componentData = componentData;
        
        // Compile behavior parameters
        if (!entity.behaviorClass.empty()) {
            compiled.behaviorClass = entity.behaviorClass;
            compiled.behaviorParams = compileBehaviorParams(entity.behaviorParams, context);
        }
        
        return compiled;
    }
    
    std::optional<std::vector<uint8_t>> compileComponent(const Component& component, 
                                                       CompilationContext& context) {
        BinaryWriter writer;
        
        switch (component.type) {
            case ComponentType::Mesh: {
                auto meshComponent = std::get<MeshComponent>(component.data);
                auto assetId = context.resolveAssetReference(meshComponent.assetRef);
                if (!assetId.has_value()) {
                    context.addError("Unknown mesh asset: " + meshComponent.assetRef);
                    return std::nullopt;
                }
                writer.writeUInt32(static_cast<uint32_t>(assetId.value()));
                break;
            }
            
            case ComponentType::Material: {
                auto materialComponent = std::get<MaterialComponent>(component.data);
                auto assetId = context.resolveAssetReference(materialComponent.assetRef);
                if (!assetId.has_value()) {
                    context.addError("Unknown material asset: " + materialComponent.assetRef);
                    return std::nullopt;
                }
                writer.writeUInt32(static_cast<uint32_t>(assetId.value()));
                break;
            }
            
            case ComponentType::Renderable: {
                auto renderableComponent = std::get<RenderableComponent>(component.data);
                writer.writeBool(renderableComponent.visible);
                writer.writeBool(renderableComponent.castShadows);
                writer.writeBool(renderableComponent.receiveShadows);
                writer.writeFloat(renderableComponent.lodBias);
                break;
            }
            
            case ComponentType::Physics: {
                auto physicsComponent = std::get<PhysicsComponent>(component.data);
                writer.writeFloat(physicsComponent.mass);
                writer.writeFloat(physicsComponent.friction);
                writer.writeFloat(physicsComponent.restitution);
                writer.writeBool(physicsComponent.isStatic);
                serializeVector3(writer, physicsComponent.centerOfMass);
                break;
            }
            
            default:
                context.addError("Unknown component type");
                return std::nullopt;
        }
        
        return writer.getData();
    }
};
```

This enhanced asset-scene compiler architecture provides the foundation for the package modularity system, enabling efficient development workflows with hot-reload while ensuring optimal production performance through pre-compiled binary packages.
│   │   │   └── city_01.pak
│   │   ├── plugins/                      # Dynamic shared libraries (.so) for ARM64
│   │   │   └── lib_city_01.so
│   │   └── cache/                        # Runtime caches (e.g., shader binaries, geometry)
│   │       └── thumb_index/              # Content-hash based index
│   └── src/                              # Main C++ engine source code
│       ├── core/
│       │   ├── AssetRegistry.h/.cpp      # Central asset storage and lookup
│       │   ├── AssetPackLoader.h/.cpp    # Loads assets from XML or binary packs
│       │   ├── EventBus.h/.cpp           # Global event dispatcher
│       │   ├── Entity.h/.cpp             # ECS Entity base class
│       │   ├── IComponent.h              # Base interface for ECS components
│       │   ├── ISystem.h                 # Base interface for ECS systems
│       │   ├── SimClock.h/.cpp           # Manages fixed timestep simulation
│       │   └── World.h/.cpp              # ECS World orchestrator
│       ├── config/
│       │   ├── SceneConfigParser.h/.cpp  # Parses XML scene definitions
│       │   └── SceneConfig.h             # C++ data structures for scene definitions
│       ├── generators/                   # Procedural asset generation logic
│       │   ├── VoxelMeshGenerator.h/.cpp # Generates meshes from parameters
│       │   ├── ProceduralTextureGenerator.h/.cpp # Generates textures from parameters
│       │   ├── BasicShaderGenerator.h/.cpp # Generates basic shader source
│       │   └── ProceduralAircraftGenerator.h/.cpp # Generates low-poly aircraft models
│       ├── systems/                      # Core ECS systems
│       │   ├── AssetHotReloadSystem.h/.cpp # Monitors files for hot-reloading
│       │   ├── BootstrapSystem.h/.cpp    # Handles initial setup and package loading
│       │   ├── WorldGenSystem.h/.cpp     # Generates/instantiates the world from scene configs
│       │   ├── VisualizationSystem.h/.cpp # Renders the scene
│       │   └── ... (PhysicsSystem, InputSystem, etc.)
│       ├── platform/
│       │   ├── IXmlParser.h              # Abstract interface for XML parsing
│       │   └── PugiXmlParser.h/.cpp      # Concrete implementation using pugixml
│       ├── vehicles/                     # Vehicle-specific builders/components
│       │   ├── IVehicleBuilder.h         # Interface for building vehicles
│       │   └── DroneBuilder.h/.cpp       # Builder for drone entities
│       └── main.cpp                      # Application entry point
```

### 3. Key Classes and Their Interactions

#### 3.1. Build Tools (Compile-Time)

These tools prepare assets for the runtime environment.

**3.1.1. `AssetCompiler` (CLI Tool)**
*   **Purpose:** Processes raw asset definitions (XML) into optimized runtime formats for production. In debug, it can convert to an in-memory Intermediate Representation (IR). It handles schema validation, parameter extraction, and various optimizations.
*   **Key Methods:**
    *   `bool ProcessAssetConfiguration(const std::string& configFile)`: Parses a package XML.
    *   `bool ValidateAgainstSchema(const std::string& xml, const std::string& schemaFile)`: Validates XML against XSD.
    *   `std::vector<Error> GetErrors() const`: Reports compilation errors.
    *   Internally, it orchestrates asset-specific cooking (e.g., mesh processing, texture compression).
*   **Interactions:**
    *   Uses `AssetSchema` for XSD validation (conceptual class representing schema operations).
    *   Invokes generator classes (`VoxelMeshGenerator`, `ProceduralTextureGenerator`, `BasicShaderGenerator`) for **parametric asset cooking**.
    *   Outputs `.pak` binary files to `runtime/data/packs/`.

**3.1.2. `SceneCompiler` (CLI Tool)**
*   **Purpose:** Transforms high-level scene definitions (XML) into optimized runtime representations. It validates scene configurations, resolves asset references (using `AssetId`s from `AssetCompiler`), and optimizes scene graphs.
*   **Key Methods:**
    *   `bool CompileScene(const std::string& sceneFile)`: Main function to process a scene XML.
    *   `void OptimizeSceneGraph(SceneGraph& scene)`: Performs scene graph optimizations.
    *   `void ResolveAssetReferences(SceneGraph& scene)`: Ensures asset references are valid.
*   **Interactions:**
    *   References `AssetCompiler`'s output (specifically, `AssetId`s) to link scene elements to cooked assets.
    *   Outputs scene data into `.pak` files, potentially as a dedicated section.

**3.1.3. `Codegen Tool` (CLI Tool)**
*   **Purpose:** Generates C++ headers or binary lookup tables that map human-readable asset names/paths (from XML) to their **stable numeric `AssetId`s** used at runtime. This enforces the "strings only at the edges" principle.
*   **Interactions:** Reads asset and scene XMLs (or the IR from `AssetCompiler`) to gather all symbolic names requiring an `AssetId`. Outputs a `AssetIds.h` header file or a binary table.

#### 3.2. Runtime Asset Management (Core Engine Components)

These components are part of the `runtime/src/core/` and `runtime/src/platform/` directories.

**3.2.1. `AssetRegistry` (`core/AssetRegistry.h/.cpp`)**
*   **Purpose:** The **central repository for all loaded assets** and scene configurations. It stores ownership (via `std::unique_ptr`) of processed assets and provides fast lookup using `AssetId`s. It's crucial for hot-reloading as it can be `clear()`ed and repopulated.
*   **Key Methods:**
    *   `void registerFont(AssetId id, std::unique_ptr<FontAsset> asset)`: Stores a font asset.
    *   `const TextureAsset* getTexture(AssetId id) const`: Retrieves a texture asset.
    *   `void registerSceneConfig(AssetId id, const std::string& sceneXml)`: Stores raw XML for scene configs (in debug) or a binary scene blob (in release).
    *   `void clear()`: Removes all registered assets and configurations. Essential for hot-reloading.
*   **Interactions:**
    *   **`AssetPackLoader`** populates the `AssetRegistry`.
    *   **`WorldGenSystem`** queries it for scene configurations and material IDs.
    *   **`VisualizationSystem`** and other systems retrieve actual asset data (e.g., meshes, textures) for use.

**3.2.2. `AssetPackLoader` (`core/AssetPackLoader.h/.cpp`)**
*   **Purpose:** The primary loader responsible for reading asset packages. In debug, it parses XML files. In release, it memory-maps and parses binary `.pak` files.
*   **Key Methods:**
    *   `bool loadPackage(const std::string& packagePath)`: Reads a package file, parses its contents, and registers assets.
    *   `bool parseAssets(const std::string& xmlContent, const std::string& packageName)`: Extracts and registers asset definitions from XML.
    *   `std::unique_ptr<TextureAsset> parseTextureAsset(const std::string& xmlNode)`: Parses specific asset types.
*   **Interactions:**
    *   Uses **`IXmlParser`** (`PugiXmlParser`) for XML parsing in debug.
    *   **Registers assets and scene configurations into the `AssetRegistry`**.
    *   Invoked by **`BootstrapSystem`** at startup and **`AssetHotReloadSystem`** on detected changes.

**3.2.3. `IXmlParser` and `PugiXmlParser` (`platform/IXmlParser.h/.cpp`, `PugiXmlParser.h/.cpp`)**
*   **Purpose:** `IXmlParser` defines a platform-independent interface for XML parsing, adhering to the IoC principle. `PugiXmlParser` is a concrete implementation using the pugixml library, injected into components needing XML parsing.
*   **Key Methods (`IXmlParser`):** `virtual bool loadFile(const std::string& path) = 0`.
*   **Interactions:** `AssetPackLoader` and `SceneConfigParser` would depend on this abstraction.

#### 3.3. ECS Systems for World Management and Hot-Reloading

These systems are located in `runtime/src/systems/`.

**3.3.1. `AssetHotReloadSystem` (`systems/AssetHotReloadSystem.h/.cpp`)**
*   **Purpose:** An **ECS system dedicated to monitoring asset and scene files for changes during development**. It's the core of the debug hot-swapping functionality.
*   **Key Methods:**
    *   `void update(World &world, float deltaTime) override`: Called every frame; checks for file modifications.
    *   `void watchPackage(const std::string &packagePath)`: Adds a package file (XML) to its watch list.
    *   `bool checkForChanges()`: Compares current file modification times with recorded ones.
    *   `void reloadChangedPackages()`: Triggers the reload process by clearing the `AssetRegistry` and re-loading the package via `AssetPackLoader`.
*   **Interactions:**
    *   Requires **`AssetRegistry` and `AssetPackLoader` injected** in its constructor.
    *   Runs at the **`EndOfFrame`** (after `VisualizationSystem`) to ensure atomic updates and avoid mid-frame mutations.
    *   Emits a `HotReloadEvent` (conceptual, via `EventBus`) to notify other systems of changes.

**3.3.2. `BootstrapSystem` (`systems/BootstrapSystem.h/.cpp`)**
*   **Purpose:** A **one-shot system** that runs at application startup to initialize the world and load initial assets. It checks for available packages, loads them, and triggers world generation.
*   **Key Methods:**
    *   `void Init()`: Called once to perform initial package loading and default scene setup.
    *   `bool LoadAvailablePackages()`: Uses `AssetPackLoader` to load initial packages (e.g., `DeveloperPackage`).
*   **Interactions:**
    *   Constructed with `EventBus`, `World`, `AssetRegistry`, and `AssetPackLoader`.
    *   Publishes `NoPackagesFoundEvent` or `DefaultWorldGeneratedEvent` via `EventBus`.

**3.3.3. `SceneConfigParser` (`config/SceneConfigParser.h/.cpp`)**
*   **Purpose:** Parses XML scene configuration files into structured C++ data (`SceneConfig::Scene`). It handles schema validation and populates data structures like `Entity`, `Material`, `Animation`, etc..
*   **Key Methods:**
    *   `ParseResult parseSceneFile(const std::string &filePath)`: Loads and parses a scene XML.
    *   `ParseResult parseSceneString(const std::string &xmlContent)`: Parses XML content directly.
    *   `bool validateAgainstSchema(const std::string &xmlContent, std::vector<std::string> &errors)`: Validates XML against the scene XSD schema.
    *   `std::shared_ptr<Entity> parseEntityFromXml(const std::string &xml)`: Parses an entity node from XML.
*   **Interactions:** Used by `WorldGenSystem` to interpret scene definitions from `AssetRegistry`.

**3.3.4. `WorldGenSystem` (`systems/WorldGenSystem.h/.cpp`)**
*   **Purpose:** Responsible for instantiating the simulation world based on scene configurations. In debug, it uses `SceneConfigParser` to read XML and procedural generators to create objects. In release, it would load pre-compiled scene data.
*   **Key Methods:**
    *   `void GenerateDefaultSphereWorld()`: Creates a hardcoded fallback scene (e.g., Earth, Atmosphere, Clouds) if no config is found.
    *   `void LoadScene(const SceneConfig::Scene &sceneData)`: Iterates through `sceneData` to create ECS entities and attach components.
    *   `AssetId GenerateVoxelMesh(const SceneConfig::CompoundMesh &meshConfig)`: Bridges to `VoxelMeshGenerator` to create procedural meshes.
*   **Interactions:**
    *   Subscribes to `NoPackagesFoundEvent` and `DefaultWorldGeneratedEvent` from `EventBus`.
    *   Uses its injected `SceneConfigParser`, `VoxelMeshGenerator`, `ProceduralTextureGenerator`, and `MaterialManager` to build the world.
    *   Adds newly created `Entities` (with `TransformC`, `RenderableC`, etc.) to the `World`.

**3.3.5. `VisualizationSystem` (`systems/VisualizationSystem.h/.cpp`)**
*   **Purpose:** Renders the 3D scene, HUD, and debug overlays. It visualizes the current state of entities in the `World`.
*   **Key Methods:**
    *   `void update(World &world, float deltaTime) override`: Main rendering loop.
    *   `void RenderEntities()`: Iterates `World::getEntities()` to draw them based on `TransformC` and `RenderableC` components.
    *   `void OnNoPackagesFound(const NoPackagesFoundEvent &event)`: Updates internal flags to display messages.
*   **Interactions:**
    *   Subscribes to `NoPackagesFoundEvent` and `ConsoleVisibilityChangedEvent`.
    *   Reads `TransformC` (position, orientation, scale) and `RenderableC` (mesh, material IDs, visibility) components from entities in the `World`.

#### 3.4. Generator Classes (Used by Compilers and `WorldGenSystem`)

These classes (`runtime/src/generators/`) encapsulate the logic for creating procedural assets.

**3.4.1. `VoxelMeshGenerator` (`generators/VoxelMeshGenerator.h/.cpp`)**
*   **Purpose:** Generates procedural meshes (cubes, spheres, cylinders, planes, or compound meshes) from given parameters. Crucial for parametric buildings and other environmental elements.
*   **Key Methods:** `VoxelMesh::MeshData generatePrimitive(const VoxelMesh::VoxelParams &params)`, `VoxelMesh::MeshData generateCompound(const VoxelMesh::CompoundParams &params)`, `VoxelMesh::MeshData generateFromParameters(const std::string &type, const std::map<std::string, std::string> &parameters)`.
*   **Interactions:** Invoked by `AssetCompiler` (for cooking) and `WorldGenSystem` (for runtime generation).

**3.4.2. `ProceduralTextureGenerator` (`generators/ProceduralTextureGenerator.h/.cpp`)**
*   **Purpose:** Generates textures based on procedural definitions (noise, gradients, patterns, composites). Useful for terrain textures, clouds, etc.
*   **Key Methods:** `static TextureData generateTexture(const TextureParams &params)`, `static TextureData generateFromParameters(const std::string &type, const std::map<std::string, std::string> &parameters)`.
*   **Interactions:** Invoked by `AssetCompiler` (for baking textures) and `MaterialManager` (for dynamic textures in `WorldGenSystem`).

### 4. Best Possible Pipeline: Debug (Hot-Swap) vs. Release (Binaries)

#### 4.1. Development Mode (Debug) - Caching and Hot-Swap

The focus is on rapid iteration without restarting the application.

1.  **Authoring (XML):** Developers modify asset definitions in XML files (`assets/packages/DeveloperPackage/*.xml`, `assets/schemas/*.xsd`, `assets/params/*.xml`).
2.  **File Watching (`AssetHotReloadSystem`):**
    *   At startup, `BootstrapSystem` loads the `DeveloperPackage/package.xml`.
    *   `AssetHotReloadSystem` starts monitoring these XML source files for changes (e.g., `watchPackage("assets/packages/DeveloperPackage/package.xml")`).
3.  **Live Compilation & Generation (In-Memory):**
    *   When `AssetHotReloadSystem` detects a change (using `checkForChanges()` with file modification timestamps), it calls `reloadChangedPackages()`.
    *   `reloadChangedPackages()` clears the entire `AssetRegistry` (a simple approach for debug, more sophisticated would be incremental) and then invokes `AssetPackLoader::loadPackage()` on the changed XML.
    *   `AssetPackLoader` uses `IXmlParser` to parse the XML into an in-memory **Intermediate Representation (IR)**.
    *   For parametric assets, the loader (or helper functions) directly calls `VoxelMeshGenerator`, `ProceduralTextureGenerator`, or `BasicShaderGenerator` to produce in-memory mesh, texture, or shader data from the XML parameters.
    *   These live-generated assets are immediately registered in the (now cleared and re-populated) `AssetRegistry`.
4.  **Caching:** The `AssetRegistry` itself serves as the cache for these in-memory, live-compiled assets.
5.  **Hot Swapping (Atomic Commit):**
    *   Crucially, the `AssetHotReloadSystem::update()` method is called at the very end of the main simulation loop, *after* `VisualizationSystem` has finished rendering the current frame.
    *   The act of `AssetRegistry::clear()` and `AssetPackLoader::loadPackage()` effectively performs the "hot-swap" by replacing all old assets with new ones.
    *   **Notification:** A `HotReloadEvent` (via `EventBus`) is then published. Systems like `WorldGenSystem` would subscribe to this event and might re-instantiate entities or re-fetch asset data from the updated `AssetRegistry` to reflect the changes dynamically.
6.  **Development Package Scene Display:** By updating `package.xml` or referenced scene XMLs, developers can modify scene elements, material properties, procedural generation parameters, and instantly see the results in the `VisualizationSystem`'s output, thanks to this hot-reloading loop. For example, changing a `ProceduralAircraftGenerator`'s parameters in XML would cause the `WorldGenSystem` to regenerate the mesh, which `VisualizationSystem` would then render.

#### 4.2. Production Mode (Release) - Optimized Binaries

The focus is on performance, minimal memory footprint, and determinism on the ARM64 target.

1.  **Build Automation (CI/CD):** A build script (e.g., `build.ps1`/`build.sh`) orchestrates the compilation process.
2.  **Asset & Scene Compilation:**
    *   **`AssetCompiler`** (CLI tool): Processes all `package.xml` and associated asset files. It performs schema validation, resolves dependencies, bakes parametric assets (by running `VoxelMeshGenerator`, `ProceduralTextureGenerator`, etc. *once* at build time), applies aggressive optimizations (mesh quantization, texture compression to GPU-native formats like KTX2/ETC2, LOD generation).
    *   **`SceneCompiler`** (CLI tool): Processes scene XMLs. It links scene elements to their compiled `AssetId`s, performs scene graph optimizations, and bakes scene configuration data.
    *   **`Codegen Tool`** (CLI tool): Scans all asset/scene definitions and generates a C++ header (e.g., `AssetIds.h`) or a binary lookup table that maps symbolic names (e.g., "earth_albedo") to **unique, stable numeric `AssetId`s** (e.g., `0xDEADBEEF`). This header is then used in the C++ engine code for asset lookups.
3.  **Binary Pack Generation (`.pak` files):** All cooked assets (meshes, textures, materials, shader binaries) and compiled scene data are bundled into **compact, memory-mappable `.pak` files** (`runtime/data/packs/DeveloperPackage.pak`). The `.pak` format includes a header and a section directory for efficient lookup by `AssetId`.
4.  **Plugin Cross-Compilation:** Any C++ components or systems intended as plugins (following the "code modules" concept) are cross-compiled for ARM64 into shared object libraries (`.so`) using `aarch64-linux-gnu-g++`. These are placed in `runtime/data/plugins/`.
5.  **Runtime Loading (Fast & Deterministic):**
    *   `BootstrapSystem` initiates loading. `AssetPackLoader` uses **memory-mapped I/O** to load `.pak` files, directly exposing their sections without copying large amounts of data.
    *   `AssetRegistry` is populated with the binary data, using the pre-generated **numeric `AssetId`s** for all lookups.
    *   A conceptual `PluginManager` (not fully detailed in sources but implied by plugin architecture) scans `runtime/data/plugins/` and uses `dlopen()` to load `.so` files, registering their component `VTable`s and systems via a stable C ABI.
    *   `WorldGenSystem` instantiates entities from the pre-compiled scene data in the `AssetRegistry`, leveraging the numeric `AssetId`s for all asset references.
6.  **Simulation Execution:** The main loop proceeds as usual, with all systems operating on the highly optimized and pre-loaded assets. The "Strings only at the edges" principle means hot paths don't incur string overheads, contributing to performance.

This dual-pipeline approach provides the best of both worlds: rapid iteration during development and highly optimized, deterministic performance in production environments.