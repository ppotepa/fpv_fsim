# 3.0 Code-Behind Behavior System

## Overview

The **Code-Behind Behavior System** enables seamless integration between declarative XML scene definitions and high-performance C++ implementations. This system allows entities defined in XML to execute custom logic through C++ classes while maintaining the flexibility of parameter-driven configuration.

## Architecture

### Behavior Interface

All behaviors implement the `EntityBehavior` interface:

```cpp
class EntityBehavior {
public:
    virtual ~EntityBehavior() = default;
    
    // Called once when behavior is attached to entity
    virtual void initialize(Entity& entity, const BehaviorParams& params) = 0;
    
    // Called every frame by BehaviorSystem
    virtual void update(Entity& entity, float deltaTime) = 0;
    
    // Called when entity receives events
    virtual void onEvent(Entity& entity, const IEvent& event) {}
    
    // Called when behavior is detached (cleanup)
    virtual void cleanup(Entity& entity) {}
};
```

### Behavior Registration

Behaviors are registered at compile-time using macros:

```cpp
// In RotatingObject.cpp
class RotatingObject : public EntityBehavior {
    // Implementation...
};

// Register behavior with string identifier
REGISTER_BEHAVIOR("behaviors.RotatingObject", RotatingObject);
```

### XML Integration

Entities in scene XML can specify behaviors:

```xml
<entity id="rotateCube" name="Rotating Cube" codeBehind="behaviors.RotatingObject">
    <transform>
        <position x="0" y="0" z="0" />
        <rotation x="0" y="0" z="0" w="1" />
        <scale x="1" y="1" z="1" />
    </transform>
    <components>
        <mesh asset="CubeMesh" />
        <material asset="RedMaterial" />
        <renderable visible="true" />
    </components>
    <!-- Parameters passed to behavior initialize() -->
    <params>
        <rotation_speed>1.5</rotation_speed>
        <rotation_axis>0 1 0</rotation_axis>
        <enable_wobble>true</enable_wobble>
        <wobble_amplitude>0.2</wobble_amplitude>
    </params>
</entity>
```

## Behavior Examples

### Simple Rotation Behavior

```cpp
class RotatingObject : public EntityBehavior {
public:
    void initialize(Entity& entity, const BehaviorParams& params) override {
        rotationSpeed = params.getFloat("rotation_speed", 1.0f);
        rotationAxis = params.getVector3("rotation_axis", {0, 1, 0});
        enableWobble = params.getBool("enable_wobble", false);
        wobbleAmplitude = params.getFloat("wobble_amplitude", 0.1f);
        
        // Normalize rotation axis
        rotationAxis = normalize(rotationAxis);
    }
    
    void update(Entity& entity, float deltaTime) override {
        auto transform = entity.getComponent<TransformC>();
        if (!transform) return;
        
        // Apply rotation
        float angle = rotationSpeed * deltaTime;
        Quaternion rotation = Quaternion::fromAxisAngle(rotationAxis, angle);
        transform->orientation = transform->orientation * rotation;
        
        // Optional wobble effect
        if (enableWobble) {
            time += deltaTime;
            float wobble = sin(time * 3.0f) * wobbleAmplitude;
            transform->position.y = originalY + wobble;
        }
    }

private:
    float rotationSpeed = 1.0f;
    Vector3 rotationAxis = {0, 1, 0};
    bool enableWobble = false;
    float wobbleAmplitude = 0.1f;
    float time = 0.0f;
    float originalY = 0.0f;
};

REGISTER_BEHAVIOR("behaviors.RotatingObject", RotatingObject);
```

### Complex Vehicle Controller

```cpp
class QuadcopterController : public EntityBehavior {
public:
    void initialize(Entity& entity, const BehaviorParams& params) override {
        // Load PID controller gains
        pidGains.kp = params.getFloat("pid_kp", 2.5f);
        pidGains.ki = params.getFloat("pid_ki", 0.1f);
        pidGains.kd = params.getFloat("pid_kd", 0.8f);
        
        // Load physical properties
        maxThrust = params.getFloat("max_thrust", 12.0f);
        mass = params.getFloat("mass", 1.2f);
        dragCoefficient = params.getFloat("drag_coefficient", 0.01f);
        
        // Initialize flight controller
        flightController.initialize(pidGains);
        
        // Subscribe to input events
        entity.subscribeToEvent<InputEvent>(
            [this](Entity& e, const InputEvent& evt) {
                this->onInputEvent(e, evt);
            });
    }
    
    void update(Entity& entity, float deltaTime) override {
        auto transform = entity.getComponent<TransformC>();
        auto physics = entity.getComponent<PhysicsC>();
        if (!transform || !physics) return;
        
        // Update flight controller
        FlightState currentState{
            .position = transform->position,
            .orientation = transform->orientation,
            .velocity = physics->velocity,
            .angularVelocity = physics->angularVelocity
        };
        
        ControlOutput output = flightController.update(
            currentState, targetState, deltaTime);
        
        // Apply forces to physics component
        Vector3 thrust = transform->orientation * Vector3{0, output.thrust, 0};
        physics->addForce(thrust);
        physics->addTorque(output.torque);
        
        // Apply drag
        Vector3 drag = -physics->velocity * dragCoefficient;
        physics->addForce(drag);
    }
    
    void onEvent(Entity& entity, const IEvent& event) override {
        if (auto inputEvent = dynamic_cast<const InputEvent*>(&event)) {
            onInputEvent(entity, *inputEvent);
        }
    }

private:
    void onInputEvent(Entity& entity, const InputEvent& event) {
        // Update target state based on input
        switch (event.action) {
            case InputAction::MOVE_FORWARD:
                targetState.velocity.z += event.value * maxSpeed;
                break;
            case InputAction::MOVE_RIGHT:
                targetState.velocity.x += event.value * maxSpeed;
                break;
            case InputAction::MOVE_UP:
                targetState.velocity.y += event.value * maxSpeed;
                break;
            case InputAction::YAW_RIGHT:
                targetYaw += event.value * maxYawRate * deltaTime;
                targetState.orientation = Quaternion::fromEuler({0, targetYaw, 0});
                break;
        }
    }

    struct PIDGains {
        float kp, ki, kd;
    } pidGains;
    
    FlightController flightController;
    FlightState targetState;
    float maxThrust;
    float mass;
    float dragCoefficient;
    float maxSpeed = 5.0f;
    float maxYawRate = 2.0f;
    float targetYaw = 0.0f;
};

REGISTER_BEHAVIOR("vehicles.QuadcopterController", QuadcopterController);
```

### Procedural System Behavior

```cpp
class CloudSystem : public EntityBehavior {
public:
    void initialize(Entity& entity, const BehaviorParams& params) override {
        cloudDensity = params.getFloat("cloud_density", 0.7f);
        driftSpeed = params.getFloat("drift_speed", 0.02f);
        spawnRate = params.getFloat("spawn_rate", 0.1f);
        maxClouds = params.getInt("max_clouds", 50);
        spawnRadius = params.getFloat("spawn_radius", 100.0f);
        
        // Initialize cloud pool
        cloudPool.reserve(maxClouds);
        for (int i = 0; i < maxClouds; ++i) {
            cloudPool.emplace_back(createCloudInstance());
        }
        
        lastSpawnTime = 0.0f;
    }
    
    void update(Entity& entity, float deltaTime) override {
        auto transform = entity.getComponent<TransformC>();
        if (!transform) return;
        
        // Update existing clouds
        for (auto& cloud : activeClouds) {
            // Drift clouds with wind
            cloud.position += windDirection * driftSpeed * deltaTime;
            
            // Update lifetime
            cloud.lifetime -= deltaTime;
            cloud.alpha = std::max(0.0f, cloud.lifetime / cloud.maxLifetime);
            
            // Update cloud mesh positions
            updateCloudMesh(cloud);
        }
        
        // Remove expired clouds
        activeClouds.erase(
            std::remove_if(activeClouds.begin(), activeClouds.end(),
                [](const Cloud& cloud) { return cloud.lifetime <= 0; }),
            activeClouds.end()
        );
        
        // Spawn new clouds
        lastSpawnTime += deltaTime;
        if (lastSpawnTime >= (1.0f / spawnRate) && activeClouds.size() < maxClouds) {
            spawnCloud(transform->position);
            lastSpawnTime = 0.0f;
        }
        
        // Update wind direction (simple noise-based)
        updateWindDirection(deltaTime);
    }

private:
    struct Cloud {
        Vector3 position;
        float lifetime;
        float maxLifetime;
        float alpha;
        float scale;
        std::vector<Vector3> vertices;
    };
    
    void spawnCloud(const Vector3& centerPos) {
        if (cloudPool.empty()) return;
        
        Cloud cloud = cloudPool.back();
        cloudPool.pop_back();
        
        // Random position around center
        float angle = randomFloat(0, 2 * PI);
        float distance = randomFloat(0, spawnRadius);
        cloud.position = centerPos + Vector3{
            cos(angle) * distance,
            randomFloat(-10, 10),
            sin(angle) * distance
        };
        
        cloud.lifetime = cloud.maxLifetime = randomFloat(30, 60);
        cloud.alpha = 1.0f;
        cloud.scale = randomFloat(0.5f, 2.0f);
        
        // Generate procedural cloud shape
        generateCloudGeometry(cloud);
        
        activeClouds.push_back(cloud);
    }
    
    void generateCloudGeometry(Cloud& cloud) {
        // Simple procedural cloud generation using noise
        cloud.vertices.clear();
        
        int detail = 20;
        for (int i = 0; i < detail; ++i) {
            for (int j = 0; j < detail; ++j) {
                float u = (float)i / detail;
                float v = (float)j / detail;
                
                // Use Perlin noise for cloud density
                float density = perlinNoise(u * 4, v * 4, 0) * cloudDensity;
                if (density > 0.3f) {
                    Vector3 vertex = {
                        (u - 0.5f) * cloud.scale,
                        density * cloud.scale * 0.5f,
                        (v - 0.5f) * cloud.scale
                    };
                    cloud.vertices.push_back(vertex);
                }
            }
        }
    }
    
    float cloudDensity;
    float driftSpeed;
    float spawnRate;
    int maxClouds;
    float spawnRadius;
    float lastSpawnTime;
    
    Vector3 windDirection = {1, 0, 0};
    std::vector<Cloud> cloudPool;
    std::vector<Cloud> activeClouds;
};

REGISTER_BEHAVIOR("environment.CloudSystem", CloudSystem);
```

## Behavior Parameters

### Parameter Types

The `BehaviorParams` class supports various data types:

```cpp
class BehaviorParams {
public:
    // Basic types
    float getFloat(const std::string& name, float defaultValue = 0.0f) const;
    int getInt(const std::string& name, int defaultValue = 0) const;
    bool getBool(const std::string& name, bool defaultValue = false) const;
    std::string getString(const std::string& name, const std::string& defaultValue = "") const;
    
    // Vector types
    Vector2 getVector2(const std::string& name, const Vector2& defaultValue = {}) const;
    Vector3 getVector3(const std::string& name, const Vector3& defaultValue = {}) const;
    Vector4 getVector4(const std::string& name, const Vector4& defaultValue = {}) const;
    
    // Color type
    Color getColor(const std::string& name, const Color& defaultValue = {1,1,1,1}) const;
    
    // Array types
    std::vector<float> getFloatArray(const std::string& name) const;
    std::vector<std::string> getStringArray(const std::string& name) const;
};
```

### XML Parameter Syntax

```xml
<params>
    <!-- Simple values -->
    <float_param>3.14</float_param>
    <int_param>42</int_param>
    <bool_param>true</bool_param>
    <string_param>hello world</string_param>
    
    <!-- Vector values (space-separated) -->
    <vector3_param>1.0 2.0 3.0</vector3_param>
    <color_param>1.0 0.5 0.0 1.0</color_param>
    
    <!-- Array values (comma-separated) -->
    <float_array>1.0, 2.0, 3.0, 4.0</float_array>
    <string_array>option1, option2, option3</string_array>
    
    <!-- Nested parameters -->
    <pid_gains kp="2.5" ki="0.1" kd="0.8" />
    <physics mass="1.2" drag="0.01" friction="0.8" />
</params>
```

## Behavior System Integration

### BehaviorSystem Class

```cpp
class BehaviorSystem : public ISystem {
public:
    void update(World& world, float deltaTime) override {
        for (auto& entity : world.getEntities()) {
            if (auto behaviorComponent = entity.getComponent<BehaviorC>()) {
                if (behaviorComponent->behavior) {
                    behaviorComponent->behavior->update(entity, deltaTime);
                }
            }
        }
    }
    
    void attachBehavior(Entity& entity, const std::string& behaviorName,
                       const BehaviorParams& params) {
        auto behavior = BehaviorRegistry::instance().create(behaviorName);
        if (behavior) {
            behavior->initialize(entity, params);
            
            auto behaviorComponent = entity.addComponent<BehaviorC>();
            behaviorComponent->behavior = std::move(behavior);
            behaviorComponent->behaviorName = behaviorName;
        }
    }
    
    void detachBehavior(Entity& entity) {
        if (auto behaviorComponent = entity.getComponent<BehaviorC>()) {
            if (behaviorComponent->behavior) {
                behaviorComponent->behavior->cleanup(entity);
            }
            entity.removeComponent<BehaviorC>();
        }
    }
};
```

### Event Integration

Behaviors can subscribe to and handle events:

```cpp
// In behavior initialize()
entity.subscribeToEvent<CollisionEvent>(
    [this](Entity& e, const CollisionEvent& evt) {
        this->onCollision(e, evt);
    });

// Event handler
void onCollision(Entity& entity, const CollisionEvent& event) {
    // Handle collision logic
    if (event.impactForce > damageThreshold) {
        takeDamage(entity, event.impactForce);
    }
}
```

## Performance Considerations

### Behavior Updates

- Behaviors are updated in a tight loop for performance
- Use object pooling for frequently created/destroyed behaviors
- Cache component references in initialize() when possible
- Avoid expensive operations in update() (file I/O, memory allocation)

### Memory Management

```cpp
class OptimizedBehavior : public EntityBehavior {
public:
    void initialize(Entity& entity, const BehaviorParams& params) override {
        // Cache component references
        transform = entity.getComponent<TransformC>();
        physics = entity.getComponent<PhysicsC>();
        
        // Pre-allocate any needed containers
        targetPositions.reserve(maxTargets);
    }
    
    void update(Entity& entity, float deltaTime) override {
        // Use cached references (faster than getComponent() each frame)
        if (transform && physics) {
            // Update logic here
        }
    }

private:
    TransformC* transform = nullptr;  // Cached component reference
    PhysicsC* physics = nullptr;
    std::vector<Vector3> targetPositions;  // Pre-allocated container
};
```

## Debugging and Development

### Debug Visualization

```cpp
#ifdef DEBUG
void DebugVisualizeBehavior(Entity& entity) {
    if (auto behaviorComponent = entity.getComponent<BehaviorC>()) {
        DebugRenderer::drawText(
            entity.getComponent<TransformC>()->position + Vector3{0, 2, 0},
            behaviorComponent->behaviorName,
            Color::yellow()
        );
    }
}
#endif
```

### Hot-Reload Support

The behavior system supports parameter hot-reloading during development:

```cpp
void BehaviorSystem::reloadBehaviorParams(Entity& entity, 
                                        const BehaviorParams& newParams) {
    if (auto behaviorComponent = entity.getComponent<BehaviorC>()) {
        if (behaviorComponent->behavior) {
            // Re-initialize behavior with new parameters
            behaviorComponent->behavior->initialize(entity, newParams);
        }
    }
}
```

This code-behind system provides a powerful bridge between declarative XML scene authoring and high-performance C++ implementation, enabling rapid development while maintaining optimal runtime performance.
