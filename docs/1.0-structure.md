# 1.0 Enhanced Component-Driven Architecture

## Overview

The FPV Flight Simulator implements a **component-driven architecture** with enhanced package modularity, designed for development/testing on Windows and production deployment on ARM64 (Cortex-A53, 1 GB RAM). The architecture emphasizes **declarative scene composition** through XML with **code-behind behaviors** for high-performance C++ extensions.

---

## Key Architectural Enhancements English version of your text, translated while keeping the technical style and structure intact:

---

Here is a proposed C++ project structure for vehicle simulation, designed for development/testing environments on Windows and production on ARM64 (Cortex-A53, 1 GB RAM), with a mini-domain architecture and IoC as the foundation.
This architecture is an adaptation of the given TypeScript architecture, which maps easily to strongly typed languages like C++.

---

### Key Architectural Principles and Adaptations

* **Mini-domain architecture (instead of full DDD):** Instead of heavy Domain-Driven Design, this approach uses clearly defined “mini-domains” (e.g., `physics/`, `vehicles/`, `systems/`). Each mini-area focuses on a specific concern, improving readability and maintainability. The inspiration comes from distinct domain boundaries mentioned in the sources (e.g., Flight Physics Domain, Control Systems Domain).

* **Inversion of Control (IoC) as a foundation:** IoC is realized through dependency injection, mainly via constructors. Systems and components rely on abstractions (interfaces) rather than concrete implementations. This supports the Open/Closed Principle (OCP), allowing new functionality to be added without modifying existing code.

* **Entity-Component-System (ECS):** This is the core pattern for organizing objects in the simulation. Vehicles are entities composed of dynamically attached components, ensuring flexibility and reusability.

* **Open/Closed Principle (OCP):** The system is open for extension but closed for modification. Achieved via interfaces, base classes, and a solid component system, allowing new features to be added without changing existing code.

* **Single Responsibility Principle (SRP):** Each component and system has one clear responsibility, simplifying maintenance and extension.

* **Event-Driven Communication:** A global EventBus provides loose coupling between systems and components, enabling flexible state change propagation and command handling.

* **Performance and Determinism:** Physics runs at a fixed timestep (e.g., 60Hz) and uses optimizations such as object pooling and spatial partitioning for smooth and repeatable simulation. This is crucial for ARM64 environments with limited RAM.

* **ARM64 Environment (Cortex-A53, 1 GB RAM):** The architecture accounts for low memory use (avoiding excessive dynamic allocations, using object pooling where possible) and high efficiency, which are critical in constrained environments. On ARM64, the simulation is assumed to run headless (logic only, no 3D rendering).

---

### C++ Project Structure

The following shows the folder/file layout with explanations of class contents, constructors, and methods.

```
project_root/
├── src/
│   ├── main.cpp
│   │   // Main application entry point. Initializes World, SimClock, EventBus,
│   │   // and registers all Systems. Creates initial entities (e.g. a drone
│   │   // via DroneBuilder). Contains the main simulation loop with fixed timestep coordination.
│   │   // Example IoC usage:
│   │   // IXmlParser* xmlParser = new PugiXmlParser();
│   │   // IVehicleBuilder* droneBuilder = new DroneBuilder(*xmlParser);
│   │   // std::unique_ptr<Entity> drone = droneBuilder->build("configs/drone_default.xml", eventBus);
│   │
│   ├── core/
│   │   // Fundamental simulation infrastructure, domain-agnostic.
│   │   ├── IEvent.h
│   │   │   // Base interface for all system events (e.g., BatteryLowEvent, CollisionEvent).
│   │   │   // Requires: virtual EventType getType() const = 0;
│   │   │   // EventType can be an enum or string.
│   │   │
│   │   ├── EventBus.h / EventBus.cpp
│   │   │   // Event-based communication (Observer pattern).
│   │   │   // Constructor: EventBus();
│   │   │   // Methods: subscribe(type, handler), publish(event).
│   │   │
│   │   ├── IComponent.h
│   │   │   // Base interface for ECS components. Pure data structures.
│   │   │
│   │   ├── Entity.h
│   │   │   // Represents a simulation object (drone, building, etc.).
│   │   │   // Constructor: Entity(unsigned int id);
│   │   │   // Methods: addComponent<T>(), getComponent<T>().
│   │   │
│   │   ├── ISystem.h
│   │   │   // Base interface for ECS systems.
│   │   │   // Requires: virtual void update(World& world, float dt) = 0;
│   │   │
│   │   ├── World.h / World.cpp
│   │   │   // Manages all entities and systems. Orchestrates simulation loop.
│   │   │   // Constructor: World(EventBus& eventBus);
│   │   │   // Methods: addEntity(), addSystem(), update().
│   │   │
│   │   ├── SimClock.h / SimClock.cpp
│   │   │   // Handles simulation time and fixed timestep logic.
│   │   │   // Constructor: SimClock(float fixedTimestep);
│   │   │   // Methods: tick(), shouldStepPhysics(), getFixedTimestep().
│   │
│   ├── components/
│   │   // ECS components (pure data structures).
│   │   // Examples: TransformC, BatteryC, SensorsC, InputC, VehicleCPUComponent, etc.
│   │
│   ├── systems/
│   │   // ECS systems (logic processors).
│   │   // Examples: InputSystem, VehicleControlSystem, PhysicsSystem, SensorSystem, WorldGenSystem, SceneLoadSystem.
│   │
│   ├── physics/
│   │   // Physics mini-domain. Abstract models + implementations.
│   │   // Examples: IAirDensityModel, ExponentialAirDensityModel, IWindModel, PerlinWindModel, ICollisionResolver, ImpulseCollisionResolver.
│   │
│   ├── vehicles/
│   │   // Vehicle mini-domain. Builders and control logic.
│   │   // Examples: IVehicleBuilder, DroneBuilder, DroneRomCode.
│   │
│   ├── utils/
│   │   // Utility classes/tools (math, XML parsing, logging).
│   │   // Examples: MathUtils, Logger, IXmlParser, PugiXmlParser.
│   │
│   └── platform/
│       // Platform-specific abstractions (e.g. input).
│       // Examples: IInputDevice, WinInputDevice, ArmInputDevice.
│
├── packages/
│   ├── schemas/      // XML schemas for config validation.
│   └── assets/       // Models, textures, shaders.
│
└── configs/
    // Simulation config files (e.g. drone_default.xml, environment_default.xml).
```

---

### IoC Implementation in C++ (“Poor Man’s DI” Example)

In C++, IoC is typically realized via constructors, passing dependencies as references/pointers to interfaces.

```cpp
int main() {
    EventBus eventBus;
    SimClock simClock(1.0f / 60.0f); // 60Hz physics
    World world(eventBus);

    // Initialize domain dependencies
    std::unique_ptr<IXmlParser> xmlParser = std::make_unique<PugiXmlParser>();
    std::unique_ptr<IAirDensityModel> airDensityModel = std::make_unique<ExponentialAirDensityModel>(1.225f, 8500.0f);
    std::unique_ptr<IWindModel> windModel = std::make_unique<PerlinWindModel>(5.0f, 100.0f, 10.0f, 12345);
    std::unique_ptr<ICollisionResolver> collisionResolver = std::make_unique<ImpulseCollisionResolver>(0.2f, 0.8f);

    // Initialize systems with DI
    std::unique_ptr<ISystem> inputSystem =
        std::make_unique<InputSystem>(eventBus, *new WinInputDevice()); // Windows input for dev/test
    std::unique_ptr<ISystem> vehicleControlSystem = std::make_unique<VehicleControlSystem>(eventBus);
    std::unique_ptr<ISystem> physicsSystem =
        std::make_unique<PhysicsSystem>(eventBus, *airDensityModel, *windModel, *collisionResolver);

    world.addSystem(std::move(inputSystem));
    world.addSystem(std::move(vehicleControlSystem));
    world.addSystem(std::move(physicsSystem));

    // Build a drone entity
    DroneBuilder droneBuilder(*xmlParser);
    std::unique_ptr<Entity> drone = droneBuilder.build("configs/drone_default.xml", eventBus);
    world.addEntity(std::move(drone));

    // Main simulation loop
    float lastFrameTime = /* get current time */;
    while (true /* exit condition */) {
        float currentFrameTime = /* get current time */;
        float frameDeltaTime = currentFrameTime - lastFrameTime;
        lastFrameTime = currentFrameTime;

        simClock.tick(frameDeltaTime);
        while (simClock.shouldStepPhysics()) {
            world.update(simClock.getFixedTimestep());
        }

        // Optional: rendering on Windows, state interpolation
    }
    return 0;
}
```

---

Do you want me to also **shorten this into a clean executive summary** (like a 1–2 page concise doc for devs), or keep it in this detailed breakdown style?
