# 1.2 Enhanced IoC Architecture with Package System Integration

## Overview

The enhanced Inversion of Control (IoC) architecture integrates seamlessly with the package modularity system, providing sophisticated dependency injection for both core engine systems and package-based behaviors. This architecture maintains the "Poor Man's DI" philosophy while adding support for dynamic behavior registration and package-level dependency management.

## 1.2.1 Core IoC Principles

### Enhanced Dependency Injection Philosophy

The enhanced IoC system builds upon the foundational constructor injection pattern while introducing package-aware dependency resolution:

**Interface-Driven Design**: All systems depend on abstractions (pure virtual classes) rather than concrete implementations, enabling flexible package-based extensions and behavior substitution.

**Package-Aware Resolution**: Dependencies can be resolved not only at application startup but also dynamically as packages are loaded, enabling hot-reload and runtime package management.

**Behavior System Integration**: The IoC container manages both traditional system dependencies and the dynamic behavior registration system used for XML-driven entities.

### Enhanced Wiring Architecture

```cpp
// Enhanced interface definitions with package support
class ISystem {
public:
    virtual ~ISystem() = default;
    virtual void initialize(World& world) = 0;
    virtual void update(World& world, float deltaTime) = 0;
    virtual void shutdown() = 0;
    
    // Package system integration
    virtual void onPackageLoaded(const Package& package) {}
    virtual void onPackageUnloaded(const Package& package) {}
};

class IAssetLoader {
public:
    virtual ~IAssetLoader() = default;
    virtual std::unique_ptr<Asset> loadAsset(const AssetDefinition& definition) = 0;
    virtual bool canHandle(AssetType type) const = 0;
    virtual std::vector<AssetType> getSupportedTypes() const = 0;
};

class IBehaviorFactory {
public:
    virtual ~IBehaviorFactory() = default;
    virtual std::unique_ptr<EntityBehavior> createBehavior(const std::string& behaviorName) = 0;
    virtual bool canCreate(const std::string& behaviorName) const = 0;
    virtual std::vector<std::string> getSupportedBehaviors() const = 0;
};
```

## 1.2.2 Enhanced Container Architecture

### Dependency Container Implementation

```cpp
class ServiceContainer {
public:
    // Traditional service registration
    template<typename TInterface, typename TImplementation, typename... Args>
    void registerSingleton(Args&&... args) {
        static_assert(std::is_base_of_v<TInterface, TImplementation>, 
                     "TImplementation must inherit from TInterface");
        
        auto service = std::make_shared<TImplementation>(std::forward<Args>(args)...);
        services[typeid(TInterface)] = service;
        
        // If this service implements multiple interfaces, register for all
        registerInterfaceImplementations<TInterface, TImplementation>(service);
    }
    
    template<typename TInterface>
    std::shared_ptr<TInterface> resolve() const {
        auto it = services.find(typeid(TInterface));
        if (it != services.end()) {
            return std::static_pointer_cast<TInterface>(it->second);
        }
        return nullptr;
    }
    
    // Package-aware service registration
    template<typename TInterface, typename TImplementation>
    void registerPackageService(const std::string& packageId) {
        auto factory = [this, packageId]() -> std::shared_ptr<TInterface> {
            return createPackageService<TInterface, TImplementation>(packageId);
        };
        
        packageFactories[packageId][typeid(TInterface)] = factory;
    }
    
    template<typename TInterface>
    std::shared_ptr<TInterface> resolvePackageService(const std::string& packageId) const {
        auto packageIt = packageFactories.find(packageId);
        if (packageIt != packageFactories.end()) {
            auto serviceIt = packageIt->second.find(typeid(TInterface));
            if (serviceIt != packageIt->second.end()) {
                return std::static_pointer_cast<TInterface>(serviceIt->second());
            }
        }
        
        // Fallback to global service
        return resolve<TInterface>();
    }
    
    // Behavior factory management
    void registerBehaviorFactory(std::unique_ptr<IBehaviorFactory> factory) {
        behaviorFactories.push_back(std::move(factory));
    }
    
    std::unique_ptr<EntityBehavior> createBehavior(const std::string& behaviorName) const {
        for (const auto& factory : behaviorFactories) {
            if (factory->canCreate(behaviorName)) {
                return factory->createBehavior(behaviorName);
            }
        }
        return nullptr;
    }

private:
    std::unordered_map<std::type_index, std::shared_ptr<void>> services;
    
    // Package-specific service factories
    using ServiceFactory = std::function<std::shared_ptr<void>()>;
    std::unordered_map<std::string, 
                      std::unordered_map<std::type_index, ServiceFactory>> packageFactories;
    
    // Behavior factories for dynamic entity behaviors
    std::vector<std::unique_ptr<IBehaviorFactory>> behaviorFactories;
    
    template<typename TInterface, typename TImplementation>
    void registerInterfaceImplementations(std::shared_ptr<TImplementation> service) {
        // Register for all base interfaces automatically
        if constexpr (std::is_base_of_v<ISystem, TImplementation>) {
            services[typeid(ISystem)] = service;
        }
        if constexpr (std::is_base_of_v<IAssetLoader, TImplementation>) {
            services[typeid(IAssetLoader)] = service;
        }
        // Add more interface registrations as needed
    }
    
    template<typename TInterface, typename TImplementation>
    std::shared_ptr<TInterface> createPackageService(const std::string& packageId) const {
        // Create package-specific service instance with package context
        auto packageManager = resolve<PackageManager>();
        auto package = packageManager->getPackage(packageId);
        
        return std::make_shared<TImplementation>(*package, *this);
    }
};
```

### Application Composition Root

```cpp
// Enhanced main.cpp with package system integration
class ApplicationComposer {
public:
    static std::unique_ptr<Application> createApplication() {
        auto container = std::make_unique<ServiceContainer>();
        
        // Register core services
        registerCoreServices(*container);
        
        // Register asset system services
        registerAssetServices(*container);
        
        // Register behavior system services
        registerBehaviorServices(*container);
        
        // Register rendering services
        registerRenderingServices(*container);
        
        // Register physics services
        registerPhysicsServices(*container);
        
        // Create application with fully configured container
        return std::make_unique<Application>(std::move(container));
    }

private:
    static void registerCoreServices(ServiceContainer& container) {
        // Event system
        container.registerSingleton<EventBus, EventBus>();
        
        // Package management
        auto xmlParser = std::make_shared<XmlParser>();
        auto fileSystem = std::make_shared<FileSystem>();
        
        container.registerSingleton<IXmlParser, XmlParser>(xmlParser);
        container.registerSingleton<IFileSystem, FileSystem>(fileSystem);
        container.registerSingleton<PackageManager, PackageManager>(
            container.resolve<IXmlParser>(),
            container.resolve<IFileSystem>()
        );
        
        // Asset registry
        container.registerSingleton<AssetRegistry, AssetRegistry>();
        
        // World management
        container.registerSingleton<World, World>(
            container.resolve<EventBus>()
        );
    }
    
    static void registerAssetServices(ServiceContainer& container) {
        // Asset compilation pipeline
        container.registerSingleton<AssetCompiler, AssetCompiler>(
            container.resolve<AssetRegistry>()
        );
        
        // Asset loaders for different types
        container.registerSingleton<MaterialLoader, MaterialLoader>();
        container.registerSingleton<MeshLoader, MeshLoader>();
        container.registerSingleton<TextureLoader, TextureLoader>();
        container.registerSingleton<ShaderLoader, ShaderLoader>();
        container.registerSingleton<AudioLoader, AudioLoader>();
        
        // Scene compiler
        container.registerSingleton<SceneCompiler, SceneCompiler>(
            container.resolve<AssetRegistry>(),
            container.resolve<ServiceContainer>()
        );
        
        // Hot-reload system (development only)
        #ifdef ENABLE_HOT_RELOAD
        container.registerSingleton<AssetHotReloadSystem, AssetHotReloadSystem>(
            container.resolve<PackageManager>(),
            container.resolve<AssetCompiler>(),
            container.resolve<EventBus>()
        );
        #endif
    }
    
    static void registerBehaviorServices(ServiceContainer& container) {
        // Behavior system
        container.registerSingleton<BehaviorSystem, BehaviorSystem>(
            container.resolve<ServiceContainer>()
        );
        
        // Core behavior factories
        container.registerBehaviorFactory(
            std::make_unique<CoreBehaviorFactory>()
        );
        
        // Vehicle behavior factories
        container.registerBehaviorFactory(
            std::make_unique<VehicleBehaviorFactory>()
        );
        
        // Environment behavior factories
        container.registerBehaviorFactory(
            std::make_unique<EnvironmentBehaviorFactory>()
        );
        
        // Developer behavior factories (development only)
        #ifdef DEBUG_BUILD
        container.registerBehaviorFactory(
            std::make_unique<DeveloperBehaviorFactory>()
        );
        #endif
    }
    
    static void registerRenderingServices(ServiceContainer& container) {
        // Rendering context
        container.registerSingleton<RenderingContext, RenderingContext>();
        
        // Shader management
        container.registerSingleton<ShaderManager, ShaderManager>(
            container.resolve<AssetRegistry>()
        );
        
        // Rendering systems
        container.registerSingleton<RenderSystem, RenderSystem>(
            container.resolve<RenderingContext>(),
            container.resolve<ShaderManager>(),
            container.resolve<EventBus>()
        );
        
        // Debug rendering (development only)
        #ifdef DEBUG_BUILD
        container.registerSingleton<DebugRenderer, DebugRenderer>(
            container.resolve<RenderingContext>()
        );
        #endif
    }
    
    static void registerPhysicsServices(ServiceContainer& container) {
        // Physics world
        container.registerSingleton<PhysicsWorld, PhysicsWorld>();
        
        // Physics system
        container.registerSingleton<PhysicsSystem, PhysicsSystem>(
            container.resolve<PhysicsWorld>(),
            container.resolve<EventBus>()
        );
        
        // Collision detection
        container.registerSingleton<ICollisionResolver, ImpulseCollisionResolver>();
        
        // Environmental physics models
        container.registerSingleton<IAirDensityModel, ExponentialAirDensityModel>();
        container.registerSingleton<IWindModel, SimpleTurbulenceWindModel>();
    }
};
```

## 1.2.3 Package-Aware Dependency Resolution

### Dynamic Service Registration

```cpp
class PackageServiceRegistry {
public:
    void registerPackage(const Package& package, ServiceContainer& container) {
        // Register package-specific asset loaders
        for (const auto& assetDef : package.assets) {
            registerAssetLoader(assetDef, container);
        }
        
        // Register package behaviors
        registerPackageBehaviors(package, container);
        
        // Register package-specific systems
        registerPackageSystems(package, container);
    }
    
    void unregisterPackage(const std::string& packageId, ServiceContainer& container) {
        // Clean up package-specific registrations
        container.unregisterPackageServices(packageId);
    }

private:
    void registerPackageBehaviors(const Package& package, ServiceContainer& container) {
        // Create behavior factory for this package
        auto factory = std::make_unique<PackageBehaviorFactory>(package.id);
        
        // Register all behaviors from this package
        for (const auto& behaviorDef : package.behaviorDefinitions) {
            factory->registerBehavior(behaviorDef.name, behaviorDef.factory);
        }
        
        container.registerBehaviorFactory(std::move(factory));
    }
    
    void registerAssetLoader(const AssetDefinition& assetDef, ServiceContainer& container) {
        switch (assetDef.type) {
            case AssetType::Material:
                if (!container.resolve<MaterialLoader>()) {
                    container.registerSingleton<MaterialLoader, MaterialLoader>();
                }
                break;
            case AssetType::Mesh:
                if (!container.resolve<MeshLoader>()) {
                    container.registerSingleton<MeshLoader, MeshLoader>();
                }
                break;
            // Add other asset types as needed
        }
    }
};
```

### Behavior Factory Integration

```cpp
class PackageBehaviorFactory : public IBehaviorFactory {
public:
    explicit PackageBehaviorFactory(const std::string& packageId)
        : packageId(packageId) {}
    
    std::unique_ptr<EntityBehavior> createBehavior(const std::string& behaviorName) override {
        auto it = behaviorFactories.find(behaviorName);
        if (it != behaviorFactories.end()) {
            return it->second();
        }
        return nullptr;
    }
    
    bool canCreate(const std::string& behaviorName) const override {
        return behaviorFactories.find(behaviorName) != behaviorFactories.end();
    }
    
    std::vector<std::string> getSupportedBehaviors() const override {
        std::vector<std::string> behaviors;
        for (const auto& [name, factory] : behaviorFactories) {
            behaviors.push_back(name);
        }
        return behaviors;
    }
    
    template<typename TBehavior>
    void registerBehavior(const std::string& behaviorName) {
        static_assert(std::is_base_of_v<EntityBehavior, TBehavior>,
                     "TBehavior must inherit from EntityBehavior");
        
        behaviorFactories[behaviorName] = []() -> std::unique_ptr<EntityBehavior> {
            return std::make_unique<TBehavior>();
        };
    }

private:
    std::string packageId;
    std::unordered_map<std::string, std::function<std::unique_ptr<EntityBehavior>()>> behaviorFactories;
};
```

## 1.2.4 Application Lifecycle Integration

### Enhanced Application Class

```cpp
class Application {
public:
    explicit Application(std::unique_ptr<ServiceContainer> container)
        : container(std::move(container)) {}
    
    void initialize() {
        // Initialize core systems
        initializeCoreServices();
        
        // Load and initialize packages
        loadPackages();
        
        // Initialize all systems
        initializeSystems();
        
        // Set up hot-reload if enabled
        #ifdef ENABLE_HOT_RELOAD
        setupHotReload();
        #endif
    }
    
    void run() {
        while (running) {
            update();
            render();
        }
    }
    
    void shutdown() {
        // Shutdown systems in reverse order
        shutdownSystems();
        
        // Unload packages
        unloadPackages();
        
        // Clean up container
        container.reset();
    }

private:
    void initializeCoreServices() {
        auto eventBus = container->resolve<EventBus>();
        auto world = container->resolve<World>();
        auto assetRegistry = container->resolve<AssetRegistry>();
        
        // Subscribe to package events
        eventBus->subscribe<PackageLoadedEvent>([this](const PackageLoadedEvent& event) {
            onPackageLoaded(event.package);
        });
        
        eventBus->subscribe<PackageUnloadedEvent>([this](const PackageUnloadedEvent& event) {
            onPackageUnloaded(event.packageId);
        });
    }
    
    void loadPackages() {
        auto packageManager = container->resolve<PackageManager>();
        auto packages = packageManager->discoverPackages("packages/");
        
        for (const auto& package : packages) {
            packageManager->loadPackage(package);
        }
    }
    
    void onPackageLoaded(const Package& package) {
        PackageServiceRegistry registry;
        registry.registerPackage(package, *container);
        
        // Notify all systems about the new package
        for (auto& system : systems) {
            system->onPackageLoaded(package);
        }
    }
    
    std::unique_ptr<ServiceContainer> container;
    std::vector<std::shared_ptr<ISystem>> systems;
    bool running = true;
};
```

This enhanced IoC architecture provides sophisticated dependency management while maintaining the simplicity and performance characteristics essential for the flight simulator application, with seamless integration of the package modularity system.
#include "systems/PhysicsSystem.h"
#include "systems/InputSystem.h"
#include "physics/ExponentialAirDensityModel.h"
#include "physics/PerlinWindModel.h"
#include "physics/ImpulseCollisionResolver.h"
#include "platform/WinInputDevice.h" // For Windows dev/test
#include "utils/PugiXmlParser.h"
#include "vehicles/DroneBuilder.h"
#include "utils/Logger.h" // For logging

int main() {
    // Core infrastructure dependencies
    EventBus eventBus;
    SimClock simClock(1.0f / 60.0f); // 60Hz physics
    World world(eventBus); // World takes EventBus by constructor injection

    Logger::logInfo("Initializing core simulation infrastructure.");

    // Concrete implementations of physics models (dependencies for PhysicsSystem)
    // Managed with unique_ptr for clear ownership
    std::unique_ptr<IAirDensityModel> airDensityModel = std::make_unique<ExponentialAirDensityModel>(1.225f, 8500.0f); //
    std::unique_ptr<IWindModel> windModel = std::make_unique<PerlinWindModel>(5.0f, 100.0f, 10.0f, 12345); //
    std::unique_ptr<ICollisionResolver> collisionResolver = std::make_unique<ImpulseCollisionResolver>(0.2f, 0.8f); //

    // Concrete implementation of an input device (dependency for InputSystem)
    // Note: For ARM64 production, this would be ArmInputDevice
    std::unique_ptr<IInputDevice> inputDevice = std::make_unique<WinInputDevice>();

    // Concrete implementation of XML parser (dependency for DroneBuilder & SceneLoadSystem)
    std::unique_ptr<IXmlParser> xmlParser = std::make_unique<PugiXmlParser>();

    Logger::logInfo("Dependencies for systems and builders instantiated.");

    // Instantiate and inject systems into the World
    // PhysicsSystem and InputSystem receive their dependencies via constructor injection
    world.addSystem(std::make_unique<PhysicsSystem>(eventBus, *airDensityModel, *windModel, *collisionResolver));
    world.addSystem(std::make_unique<InputSystem>(eventBus, *inputDevice));
    world.addSystem(std::make_unique<VehicleControlSystem>(eventBus));
    world.addSystem(std::make_unique<SensorSystem>(eventBus, /* INoiseModelFactory& */)); // Needs a noise model factory
    world.addSystem(std::make_unique<WorldGenSystem>(eventBus, /* IHeightfieldGenerator&, IBuildingGenerator& */));
    world.addSystem(std::make_unique<SceneLoadSystem>(eventBus, *xmlParser, /* ISceneLoader& */));
    // ... add other systems (e.g., VisualizationSystem on Windows)

    Logger::logInfo("Systems registered with the World.");

    // Use a builder with injected dependencies to create entities
    DroneBuilder droneBuilder(*xmlParser); // DroneBuilder receives IXmlParser by constructor injection
    std::unique_ptr<Entity> drone = droneBuilder.build("configs/drone_default.xml", eventBus);
    world.addEntity(std::move(drone));

    Logger::logInfo("Initial drone entity created and added to the World.");

    // Main simulation loop
    // ... (as described in previous steps)

    return 0;
}
```

**Benefits of this Wiring Structure:**

*   **Loose Coupling:** Components don't know about each other's concrete types, only their interfaces. This makes them independent and easily replaceable.
*   **Testability:** Because dependencies are external, mock or stub implementations can be easily injected during testing without modifying the component's code.
*   **Extensibility (OCP):** New functionalities (e.g., a new wind model, a different input device) can be added by creating new implementations of interfaces and injecting them, without altering existing code.

### Registration Types

In the context of "Poor Man's DI" in C++, explicit "registration" in a separate configuration often isn't performed in the same way as with full-fledged IoC containers in other languages (e.g., XML configurations or code-based fluent APIs). Instead, the "registration" is essentially **manual wiring within the composition root (`main.cpp`)**.

1.  **Interface to Concrete Type Mapping:** This mapping is established directly in `main.cpp` when you write:
    `std::unique_ptr<IAirDensityModel> airDensityModel = std::make_unique<ExponentialAirDensityModel>();`
    Here, `IAirDensityModel` is "mapped" to `ExponentialAirDensityModel`.
2.  **Lifetime Management:** `std::unique_ptr` and `std::shared_ptr` are used to manage the lifetime of the created instances, ensuring proper resource deallocation.
    *   `std::unique_ptr`: For dependencies that have a single owner (e.g., `airDensityModel` in the example).
    *   `std::shared_ptr`: For dependencies that might be shared among multiple components and whose lifetime needs to be managed jointly.

This manual approach is clean and understandable for a project of this scale, especially with the clear mini-domain structure and a finite set of core services.

### Choosing a Proper IoC Container for Our Case

Given the project's requirements:
*   **C++ language:** Full-blown IoC containers are less common and often more complex in C++ than in languages with runtime reflection capabilities.
*   **Minimal Tooling:** A heavy, third-party IoC container library (like Boost.DI or Hypodermic) might introduce significant dependencies, compilation overhead, and complexity, which could contradict the "minimal tooling" directive [Previous turn].
*   **"Poor Man's DI" as basis:** The sources explicitly mention "Poor Man's DI".

Therefore, the **most proper "IoC Container" for our case, adhering to the "minimal tooling" philosophy and the existing architectural principles, is to stick with and formalize the "Poor Man's DI" approach within `main.cpp` and, if truly necessary, implement a very lightweight, custom factory/registry.**

**Recommendation:**

1.  **Primary Approach: "Poor Man's DI" in `main.cpp`:**
    *   Continue using `main.cpp` as the primary composition root. This is where all top-level dependencies are instantiated and explicitly injected into systems and builders via their constructors.
    *   This approach is simple, explicit, avoids external dependencies, and is perfectly adequate for managing the core services of this simulation.
    *   It offers direct control over object lifetimes and creation logic, which is beneficial for performance and memory management in the ARM64 environment.

2.  **Optional (if complexity grows): A Custom, Lightweight Factory/Registry:**
    *   If the number of services or their creation logic becomes overly complex within `main.cpp`, a **custom, minimal factory or registry class** could be introduced. This would not be a full-blown IoC container library, but rather a simple class to centralize the creation and ownership of specific dependencies.
    *   **Structure:**
        ```cpp
        // utils/ServiceLocator.h (or DependencyContainer.h)
        #include <memory>
        #include <map>
        #include <functional>
        #include <typeindex>

        class ServiceLocator {
        public:
            template<typename Interface, typename Concrete, typename... Args>
            void registerSingleton(Args&&... args) {
                // For a singleton, create once and store.
                // This would be simplified; for a real service locator, you'd store a std::function<std::unique_ptr<Interface>()>
                // and resolve it, or manage shared_ptr.
                // For simplicity here, we assume concrete objects are directly injectable.
            }

            template<typename Interface>
            Interface& resolve() {
                // Returns a reference to a pre-registered instance.
                // This would require a map<std::type_index, std::shared_ptr<void>> internally.
            }
            // ... more methods for transient, factory-based registrations if needed
        private:
            // Placeholder: A real implementation would involve a map of type_index to shared_ptr<void>
            // and functions to create instances.
        };
        ```
    *   **Usage:** `main.cpp` would instantiate `ServiceLocator`, "register" dependencies by providing creation functions or instances, and then `System`s could (less ideally, or via factories) request dependencies from it. However, this could introduce a "Service Locator anti-pattern" if not used carefully, as it might hide dependencies rather than explicitly declaring them.
    *   **Recommendation:** Given the current stage and "minimal tooling", the explicit **constructor injection in `main.cpp` is the preferred and most transparent method.** Only consider a custom factory/registry if `main.cpp` becomes genuinely unmanageable, ensuring that even then, it remains minimal and tightly controlled.

By adhering to manual constructor injection, the project maintains control over dependencies, keeps the tooling minimal, and directly implements the IoC principles outlined in the architecture.