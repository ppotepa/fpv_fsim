Okay, let's detail the **IoC wiring structure** for our C++ project, including registration types and selecting a suitable IoC approach, keeping in mind the "minimal tooling" directive and the C++ context.

### 1.2 IoC Wiring Structure

The core principle of **Inversion of Control (IoC)** in this architecture is realized through **Dependency Injection (DI)**, primarily via **constructor injection**. This approach is explicitly referred to as "Poor Man's DI" in the sources, indicating a preference for simplicity and directness over heavy frameworks.

**How Classes are Wired (Constructor Injection):**

1.  **Interfaces (Abstractions):** The foundation of IoC is the use of interfaces (pure virtual classes in C++). Systems and components **depend on these abstractions**, not on concrete implementations.
    *   **Example:** `PhysicsSystem` depends on `IAirDensityModel`, `IWindModel`, and `ICollisionResolver` interfaces, not specific classes like `ExponentialAirDensityModel` or `ImpulseCollisionResolver` [See `PhysicsSystem.h` in the proposed structure].
2.  **Constructor Parameters:** Classes declare their dependencies as parameters in their constructors. These parameters are typically references (`&`) or `std::unique_ptr` (for ownership) or `std::shared_ptr` (for shared ownership) to the interface types.
    *   **Example:**
        ```cpp
        class PhysicsSystem : public ISystem {
        public:
            PhysicsSystem(EventBus& eventBus, IAirDensityModel& airDensityModel, IWindModel& windModel, ICollisionResolver& collisionResolver);
            // ... methods
        };
        ```
        Here, `PhysicsSystem` explicitly states its need for `EventBus`, `IAirDensityModel`, `IWindModel`, and `ICollisionResolver` at construction.
3.  **Composition Root (`main.cpp`):** The `main.cpp` file serves as the **composition root**. This is the single place where:
    *   All necessary concrete implementations of interfaces are instantiated.
    *   These concrete instances are then passed into the constructors of other dependent classes.
    *   This ensures that dependencies are resolved at application startup, and components are always created with their required services.

**Example Wiring Flow in `main.cpp` (Expanded):**

```cpp
#include "core/EventBus.h"
#include "core/World.h"
#include "systems/PhysicsSystem.h"
#include "systems/InputSystem.h"
#include "physics/ExponentialAirDensityModel.h"
#include "physics/PerlinWindModel.h"
#include "physics/ImpulseCollisionResolver.h"
#include "platform/WinInputDevice.h" // For Windows dev/test
#include "utils/PugiXmlParser.h"
#include "vehicles/DroneBuilder.h"
#include "utils/Logger.h" // For logging

int main() {
    // Core infrastructure dependencies
    EventBus eventBus;
    SimClock simClock(1.0f / 60.0f); // 60Hz physics
    World world(eventBus); // World takes EventBus by constructor injection

    Logger::logInfo("Initializing core simulation infrastructure.");

    // Concrete implementations of physics models (dependencies for PhysicsSystem)
    // Managed with unique_ptr for clear ownership
    std::unique_ptr<IAirDensityModel> airDensityModel = std::make_unique<ExponentialAirDensityModel>(1.225f, 8500.0f); //
    std::unique_ptr<IWindModel> windModel = std::make_unique<PerlinWindModel>(5.0f, 100.0f, 10.0f, 12345); //
    std::unique_ptr<ICollisionResolver> collisionResolver = std::make_unique<ImpulseCollisionResolver>(0.2f, 0.8f); //

    // Concrete implementation of an input device (dependency for InputSystem)
    // Note: For ARM64 production, this would be ArmInputDevice
    std::unique_ptr<IInputDevice> inputDevice = std::make_unique<WinInputDevice>();

    // Concrete implementation of XML parser (dependency for DroneBuilder & SceneLoadSystem)
    std::unique_ptr<IXmlParser> xmlParser = std::make_unique<PugiXmlParser>();

    Logger::logInfo("Dependencies for systems and builders instantiated.");

    // Instantiate and inject systems into the World
    // PhysicsSystem and InputSystem receive their dependencies via constructor injection
    world.addSystem(std::make_unique<PhysicsSystem>(eventBus, *airDensityModel, *windModel, *collisionResolver));
    world.addSystem(std::make_unique<InputSystem>(eventBus, *inputDevice));
    world.addSystem(std::make_unique<VehicleControlSystem>(eventBus));
    world.addSystem(std::make_unique<SensorSystem>(eventBus, /* INoiseModelFactory& */)); // Needs a noise model factory
    world.addSystem(std::make_unique<WorldGenSystem>(eventBus, /* IHeightfieldGenerator&, IBuildingGenerator& */));
    world.addSystem(std::make_unique<SceneLoadSystem>(eventBus, *xmlParser, /* ISceneLoader& */));
    // ... add other systems (e.g., VisualizationSystem on Windows)

    Logger::logInfo("Systems registered with the World.");

    // Use a builder with injected dependencies to create entities
    DroneBuilder droneBuilder(*xmlParser); // DroneBuilder receives IXmlParser by constructor injection
    std::unique_ptr<Entity> drone = droneBuilder.build("configs/drone_default.xml", eventBus);
    world.addEntity(std::move(drone));

    Logger::logInfo("Initial drone entity created and added to the World.");

    // Main simulation loop
    // ... (as described in previous steps)

    return 0;
}
```

**Benefits of this Wiring Structure:**

*   **Loose Coupling:** Components don't know about each other's concrete types, only their interfaces. This makes them independent and easily replaceable.
*   **Testability:** Because dependencies are external, mock or stub implementations can be easily injected during testing without modifying the component's code.
*   **Extensibility (OCP):** New functionalities (e.g., a new wind model, a different input device) can be added by creating new implementations of interfaces and injecting them, without altering existing code.

### Registration Types

In the context of "Poor Man's DI" in C++, explicit "registration" in a separate configuration often isn't performed in the same way as with full-fledged IoC containers in other languages (e.g., XML configurations or code-based fluent APIs). Instead, the "registration" is essentially **manual wiring within the composition root (`main.cpp`)**.

1.  **Interface to Concrete Type Mapping:** This mapping is established directly in `main.cpp` when you write:
    `std::unique_ptr<IAirDensityModel> airDensityModel = std::make_unique<ExponentialAirDensityModel>();`
    Here, `IAirDensityModel` is "mapped" to `ExponentialAirDensityModel`.
2.  **Lifetime Management:** `std::unique_ptr` and `std::shared_ptr` are used to manage the lifetime of the created instances, ensuring proper resource deallocation.
    *   `std::unique_ptr`: For dependencies that have a single owner (e.g., `airDensityModel` in the example).
    *   `std::shared_ptr`: For dependencies that might be shared among multiple components and whose lifetime needs to be managed jointly.

This manual approach is clean and understandable for a project of this scale, especially with the clear mini-domain structure and a finite set of core services.

### Choosing a Proper IoC Container for Our Case

Given the project's requirements:
*   **C++ language:** Full-blown IoC containers are less common and often more complex in C++ than in languages with runtime reflection capabilities.
*   **Minimal Tooling:** A heavy, third-party IoC container library (like Boost.DI or Hypodermic) might introduce significant dependencies, compilation overhead, and complexity, which could contradict the "minimal tooling" directive [Previous turn].
*   **"Poor Man's DI" as basis:** The sources explicitly mention "Poor Man's DI".

Therefore, the **most proper "IoC Container" for our case, adhering to the "minimal tooling" philosophy and the existing architectural principles, is to stick with and formalize the "Poor Man's DI" approach within `main.cpp` and, if truly necessary, implement a very lightweight, custom factory/registry.**

**Recommendation:**

1.  **Primary Approach: "Poor Man's DI" in `main.cpp`:**
    *   Continue using `main.cpp` as the primary composition root. This is where all top-level dependencies are instantiated and explicitly injected into systems and builders via their constructors.
    *   This approach is simple, explicit, avoids external dependencies, and is perfectly adequate for managing the core services of this simulation.
    *   It offers direct control over object lifetimes and creation logic, which is beneficial for performance and memory management in the ARM64 environment.

2.  **Optional (if complexity grows): A Custom, Lightweight Factory/Registry:**
    *   If the number of services or their creation logic becomes overly complex within `main.cpp`, a **custom, minimal factory or registry class** could be introduced. This would not be a full-blown IoC container library, but rather a simple class to centralize the creation and ownership of specific dependencies.
    *   **Structure:**
        ```cpp
        // utils/ServiceLocator.h (or DependencyContainer.h)
        #include <memory>
        #include <map>
        #include <functional>
        #include <typeindex>

        class ServiceLocator {
        public:
            template<typename Interface, typename Concrete, typename... Args>
            void registerSingleton(Args&&... args) {
                // For a singleton, create once and store.
                // This would be simplified; for a real service locator, you'd store a std::function<std::unique_ptr<Interface>()>
                // and resolve it, or manage shared_ptr.
                // For simplicity here, we assume concrete objects are directly injectable.
            }

            template<typename Interface>
            Interface& resolve() {
                // Returns a reference to a pre-registered instance.
                // This would require a map<std::type_index, std::shared_ptr<void>> internally.
            }
            // ... more methods for transient, factory-based registrations if needed
        private:
            // Placeholder: A real implementation would involve a map of type_index to shared_ptr<void>
            // and functions to create instances.
        };
        ```
    *   **Usage:** `main.cpp` would instantiate `ServiceLocator`, "register" dependencies by providing creation functions or instances, and then `System`s could (less ideally, or via factories) request dependencies from it. However, this could introduce a "Service Locator anti-pattern" if not used carefully, as it might hide dependencies rather than explicitly declaring them.
    *   **Recommendation:** Given the current stage and "minimal tooling", the explicit **constructor injection in `main.cpp` is the preferred and most transparent method.** Only consider a custom factory/registry if `main.cpp` becomes genuinely unmanageable, ensuring that even then, it remains minimal and tightly controlled.

By adhering to manual constructor injection, the project maintains control over dependencies, keeps the tooling minimal, and directly implements the IoC principles outlined in the architecture.