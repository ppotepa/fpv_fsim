# 1.1 Enhanced Development Toolchain

## Overview

The enhanced development toolchain supports the package modularity architecture with sophisticated build systems, cross-platform compilation, and integrated development workflows. This toolchain enables efficient development on Windows with deployment targeting ARM64 production environments while supporting the enhanced XML-based scene authoring and code-behind behavior systems.

## 1.1.1 Core Development Environment

### Primary Development Platform (Windows)

**Compiler Toolchain:**
- **MSVC 2022 (Primary)**: Latest Visual Studio 2022 with C++20 support for enhanced template metaprogramming and concepts used in the behavior system
- **Clang 15+ (Alternative)**: Clang-cl integration for advanced diagnostics and cross-platform compatibility validation
- **GCC 12+ (MinGW-w64)**: Optional GNU toolchain for compatibility testing and specific optimizations

**Build System Integration:**
```cmake
# Enhanced CMakeLists.txt configuration
cmake_minimum_required(VERSION 3.25)
project(FPVFlightSimulator VERSION 1.0.0 LANGUAGES CXX)

# C++20 requirement for enhanced package system
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Platform-specific configurations
if(WIN32)
    # Windows development configuration
    set(CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS ON)
    set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
    set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
    
    # Enhanced debugging support
    if(CMAKE_BUILD_TYPE STREQUAL "Debug")
        target_compile_definitions(fpv_fsim PRIVATE 
            DEBUG_BUILD=1
            ENABLE_HOT_RELOAD=1
            ENABLE_ASSET_VALIDATION=1
        )
    endif()
    
elseif(CMAKE_SYSTEM_PROCESSOR MATCHES "aarch64|arm64")
    # ARM64 production configuration
    set(CMAKE_TOOLCHAIN_FILE ${CMAKE_SOURCE_DIR}/toolchain-arm64.cmake)
    
    # Performance optimizations for ARM64
    target_compile_options(fpv_fsim PRIVATE
        -march=armv8-a
        -mtune=cortex-a53
        -O3
        -flto
    )
    
    # Production definitions
    target_compile_definitions(fpv_fsim PRIVATE 
        PRODUCTION_BUILD=1
        ENABLE_BINARY_PACKAGES=1
        DISABLE_DEBUG_FEATURES=1
    )
endif()

# Package system dependencies
find_package(SDL2 REQUIRED)
find_package(OpenGL REQUIRED)
find_package(pugixml REQUIRED)  # XML parsing for package system

# Enhanced package compilation tool
add_subdirectory(build_tools/package_compiler)
add_subdirectory(build_tools/hot_reload_server)
add_subdirectory(build_tools/asset_validator)

# Main executable with package support
add_executable(fpv_fsim
    src/main.cpp
    src/core/Application.cpp
    src/assets/PackageManager.cpp
    src/assets/AssetRegistry.cpp
    src/systems/BehaviorSystem.cpp
    src/systems/RenderSystem.cpp
    src/systems/PhysicsSystem.cpp
    # ... additional source files
)

target_link_libraries(fpv_fsim
    SDL2::SDL2
    SDL2::SDL2main
    OpenGL::GL
    pugixml::pugixml
)

# Package compilation targets
add_custom_target(compile_packages
    COMMAND package_compiler 
        --input ${CMAKE_SOURCE_DIR}/packages
        --output ${CMAKE_BINARY_DIR}/runtime/data/compiled
        --mode development
    DEPENDS package_compiler
    COMMENT "Compiling development packages"
)

add_custom_target(compile_packages_release
    COMMAND package_compiler 
        --input ${CMAKE_SOURCE_DIR}/packages
        --output ${CMAKE_BINARY_DIR}/runtime/data/compiled
        --mode production
        --optimize
    DEPENDS package_compiler
    COMMENT "Compiling optimized production packages"
)
```

### Graphics and Windowing Libraries

**SDL2 Configuration:**
```cmake
# Enhanced SDL2 setup with package system integration
if(WIN32)
    # Windows SDL2 development setup
    set(SDL2_DIR "${CMAKE_SOURCE_DIR}/third_party/SDL2-2.28.0")
    find_package(SDL2 REQUIRED CONFIG)
    
    # Copy SDL2 DLLs for development
    add_custom_command(TARGET fpv_fsim POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
            $<TARGET_FILE:SDL2::SDL2>
            $<TARGET_FILE_DIR:fpv_fsim>
    )
    
elseif(CMAKE_SYSTEM_PROCESSOR MATCHES "aarch64")
    # ARM64 SDL2 cross-compilation
    set(SDL2_ROOT "${SYSROOT}/usr")
    find_package(SDL2 REQUIRED)
    
    # Link static libraries for ARM64 deployment
    target_link_libraries(fpv_fsim SDL2::SDL2-static)
endif()

# OpenGL context configuration
target_compile_definitions(fpv_fsim PRIVATE
    GL_VERSION_MAJOR=3
    GL_VERSION_MINOR=3
    ENABLE_GL_DEBUG_CONTEXT=$<BOOL:${CMAKE_BUILD_TYPE STREQUAL "Debug"}>
)
```

**OpenGL Integration:**
- **Windows**: OpenGL 4.6 with debug context for development
- **ARM64**: OpenGL ES 3.2 for production deployment
- **GLEW/glad**: Extension loading with package-based shader management

## 1.1.2 Package Development Tools

### Package Compiler Architecture

**Core Compilation Tools:**
```cpp
// Package compiler tool main entry point
class PackageCompilerTool {
public:
    struct CommandLineOptions {
        std::string inputDirectory;
        std::string outputDirectory;
        std::string mode = "development";  // development/production
        bool enableOptimization = false;
        bool enableValidation = true;
        bool verbose = false;
    };
    
    int main(int argc, char* argv[]) {
        auto options = parseCommandLine(argc, argv);
        
        if (!validateInputs(options)) {
            std::cerr << "Invalid input parameters\n";
            return 1;
        }
        
        PackageCompiler compiler;
        PackageCompiler::Config config;
        config.developmentMode = (options.mode == "development");
        config.enableOptimization = options.enableOptimization;
        config.outputDirectory = options.outputDirectory;
        
        auto result = compiler.compileAllPackages(options.inputDirectory, config);
        
        if (!result.success) {
            std::cerr << "Compilation failed:\n";
            for (const auto& error : result.errors) {
                std::cerr << "  ERROR: " << error << "\n";
            }
            return 1;
        }
        
        if (options.verbose) {
            std::cout << "Compilation successful:\n";
            std::cout << "  Compiled " << result.stats.compiledAssets << " assets\n";
            std::cout << "  Compiled " << result.stats.compiledScenes << " scenes\n";
            std::cout << "  Total size: " << result.stats.totalSize << " bytes\n";
        }
        
        return 0;
    }
};
```

### Hot-Reload Development Server

**File System Monitoring:**
```cpp
class HotReloadServer {
public:
    void initialize(const std::string& packagesDirectory) {
        // Initialize file system watcher
        fileWatcher = std::make_unique<FileSystemWatcher>(packagesDirectory);
        
        // Set up change detection
        fileWatcher->onChanged([this](const std::string& path) {
            scheduleRecompilation(path);
        });
        
        // Start monitoring thread
        monitoringThread = std::thread([this]() {
            this->monitoringLoop();
        });
        
        // Start network server for runtime communication
        networkServer = std::make_unique<TCPServer>(HOT_RELOAD_PORT);
        networkServer->onClientConnected([this](ClientId client) {
            connectedClients.insert(client);
        });
    }
    
    void broadcastReload(const std::vector<AssetId>& reloadedAssets) {
        HotReloadMessage message;
        message.type = HotReloadMessage::ASSETS_RELOADED;
        message.assetIds = reloadedAssets;
        
        auto serialized = serializeMessage(message);
        
        for (auto client : connectedClients) {
            networkServer->sendToClient(client, serialized);
        }
    }

private:
    void scheduleRecompilation(const std::string& changedPath) {
        std::lock_guard<std::mutex> lock(pendingMutex);
        pendingRecompiles.insert(changedPath);
    }
    
    void monitoringLoop() {
        while (running) {
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            
            std::set<std::string> toProcess;
            {
                std::lock_guard<std::mutex> lock(pendingMutex);
                toProcess = std::move(pendingRecompiles);
                pendingRecompiles.clear();
            }
            
            if (!toProcess.empty()) {
                processRecompilation(toProcess);
            }
        }
    }
    
    std::unique_ptr<FileSystemWatcher> fileWatcher;
    std::unique_ptr<TCPServer> networkServer;
    std::thread monitoringThread;
    std::atomic<bool> running{true};
    std::mutex pendingMutex;
    std::set<std::string> pendingRecompiles;
    std::set<ClientId> connectedClients;
    
    static constexpr uint16_t HOT_RELOAD_PORT = 8888;
};
```

## 1.1.3 Cross-Platform Build Configuration

### ARM64 Production Toolchain

**Toolchain Configuration (toolchain-arm64.cmake):**
```cmake
# ARM64 cross-compilation toolchain
set(CMAKE_SYSTEM_NAME Linux)
set(CMAKE_SYSTEM_PROCESSOR aarch64)

# Cross-compiler configuration
set(CMAKE_C_COMPILER aarch64-linux-gnu-gcc)
set(CMAKE_CXX_COMPILER aarch64-linux-gnu-g++)

# Sysroot for ARM64 libraries
set(CMAKE_SYSROOT ${CMAKE_CURRENT_LIST_DIR}/sysroot-arm64)

# Search paths
set(CMAKE_FIND_ROOT_PATH ${CMAKE_SYSROOT})
set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)

# ARM64-specific optimizations
set(CMAKE_CXX_FLAGS_RELEASE "-O3 -DNDEBUG -flto -march=armv8-a -mtune=cortex-a53")
set(CMAKE_C_FLAGS_RELEASE "-O3 -DNDEBUG -flto -march=armv8-a -mtune=cortex-a53")

# Link-time optimization
set(CMAKE_INTERPROCEDURAL_OPTIMIZATION_RELEASE TRUE)

# Package system configuration for production
add_definitions(
    -DPRODUCTION_BUILD=1
    -DENABLE_BINARY_PACKAGES=1
    -DDISABLE_HOT_RELOAD=1
    -DMINIMAL_LOGGING=1
)
```

### Build Script Integration

**PowerShell Build Script (build.ps1):**
```powershell
# Enhanced build script with package compilation
param(
    [string]$Configuration = "Debug",
    [string]$Platform = "Windows",
    [switch]$CompilePackages = $false,
    [switch]$Clean = $false,
    [switch]$Verbose = $false
)

Write-Host "FPV Flight Simulator Build Script" -ForegroundColor Green
Write-Host "Configuration: $Configuration" -ForegroundColor Yellow
Write-Host "Platform: $Platform" -ForegroundColor Yellow

# Clean build directory if requested
if ($Clean) {
    Write-Host "Cleaning build directory..." -ForegroundColor Yellow
    Remove-Item -Recurse -Force "build-*" -ErrorAction SilentlyContinue
}

# Configure build based on platform
switch ($Platform) {
    "Windows" {
        $BuildDir = "build-debug"
        $CMakeArgs = @(
            "-G", "Visual Studio 17 2022",
            "-A", "x64",
            "-DCMAKE_BUILD_TYPE=$Configuration"
        )
    }
    "ARM64" {
        $BuildDir = "build-arm64"
        $CMakeArgs = @(
            "-G", "Unix Makefiles",
            "-DCMAKE_TOOLCHAIN_FILE=toolchain-arm64.cmake",
            "-DCMAKE_BUILD_TYPE=Release"
        )
    }
}

# Create and enter build directory
New-Item -ItemType Directory -Force -Path $BuildDir | Out-Null
Set-Location $BuildDir

# Configure with CMake
Write-Host "Configuring with CMake..." -ForegroundColor Yellow
& cmake .. @CMakeArgs
if ($LASTEXITCODE -ne 0) {
    Write-Error "CMake configuration failed"
    exit 1
}

# Build the project
Write-Host "Building project..." -ForegroundColor Yellow
if ($Platform -eq "Windows") {
    & cmake --build . --config $Configuration
} else {
    & cmake --build . -j $(nproc)
}

if ($LASTEXITCODE -ne 0) {
    Write-Error "Build failed"
    exit 1
}

# Compile packages if requested
if ($CompilePackages) {
    Write-Host "Compiling packages..." -ForegroundColor Yellow
    
    if ($Platform -eq "Windows") {
        & .\bin\package_compiler.exe --input ..\packages --output .\runtime\data\compiled --mode development
    } else {
        & ./bin/package_compiler --input ../packages --output ./runtime/data/compiled --mode production --optimize
    }
    
    if ($LASTEXITCODE -ne 0) {
        Write-Error "Package compilation failed"
        exit 1
    }
}

Write-Host "Build completed successfully!" -ForegroundColor Green
```

## 1.1.4 Development Environment Integration

### Visual Studio Code Configuration

**Enhanced VSCode Settings (.vscode/settings.json):**
```json
{
    "C_Cpp.default.configurationProvider": "ms-vscode.cmake-tools",
    "C_Cpp.default.cppStandard": "c++20",
    "C_Cpp.default.compilerPath": "cl.exe",
    "C_Cpp.default.includePath": [
        "${workspaceFolder}/src/**",
        "${workspaceFolder}/packages/**",
        "${workspaceFolder}/third_party/**"
    ],
    "C_Cpp.default.defines": [
        "_DEBUG",
        "UNICODE",
        "_UNICODE",
        "ENABLE_HOT_RELOAD=1",
        "ENABLE_PACKAGE_SYSTEM=1"
    ],
    "cmake.configureArgs": [
        "-DCMAKE_BUILD_TYPE=Debug",
        "-DENABLE_HOT_RELOAD=ON"
    ],
    "files.associations": {
        "*.xml": "xml",
        "package.xml": "xml"
    },
    "xml.validation.enabled": true,
    "xml.validation.schema": [
        {
            "fileMatch": ["**/packages/**/package.xml"],
            "uri": "file://${workspaceFolder}/assets/schemas/package.xsd"
        }
    ]
}
```

**Tasks Configuration (.vscode/tasks.json):**
```json
{
    "version": "2.0.0",
    "tasks": [
        {
            "label": "Build Debug",
            "type": "shell",
            "command": "powershell",
            "args": ["-File", "build.ps1", "-Configuration", "Debug", "-CompilePackages"],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "presentation": {
                "echo": true,
                "reveal": "always",
                "focus": false,
                "panel": "shared"
            }
        },
        {
            "label": "Build ARM64 Release",
            "type": "shell",
            "command": "powershell",
            "args": ["-File", "build.ps1", "-Platform", "ARM64", "-CompilePackages"],
            "group": "build"
        },
        {
            "label": "Compile Packages Only",
            "type": "shell",
            "command": "build-debug/bin/package_compiler.exe",
            "args": [
                "--input", "packages",
                "--output", "build-debug/runtime/data/compiled",
                "--mode", "development",
                "--verbose"
            ],
            "group": "build"
        },
        {
            "label": "Start Hot Reload Server",
            "type": "shell",
            "command": "build-debug/bin/hot_reload_server.exe",
            "args": ["--packages", "packages", "--port", "8888"],
            "isBackground": true,
            "problemMatcher": []
        }
    ]
}
```

This enhanced toolchain provides comprehensive support for the package modularity architecture while maintaining efficient development workflows and cross-platform deployment capabilities.
    *   **Visual Studio Code (VS Code):** Jest to lekki, ale bardzo funkcjonalny edytor z doskonałym wsparciem dla C++ (poprzez rozszerzenia C/C++) i CMake. Umożliwia również zdalne debugowanie na platformach ARM. [Informacja spoza źródeł]
    *   **Inne:** Każdy edytor tekstu (Notepad++, Sublime Text, Vim) może być używany, ale VS Code oferuje znacznie lepszą integrację z narzędziami. [Informacja spoza źródeł]
*   **Debuger:**
    *   **GDB (GNU Debugger):** Standardowy debuger dla GCC/Clang. Na Windowsie można użyć natywnej wersji GDB. Dla ARM64, będziesz potrzebować **cross-debuggera GDB** (np. `aarch64-linux-gnu-gdb`) i zdalnego debugowania, gdzie debuger na Windowsie łączy się z programem działającym na docelowym sprzęcie ARM. [Informacja spoza źródeł]

**Podsumowanie minimalnego stosu narzędzi:**

*   **Kompilator (Windows):** MinGW-w64 (GCC)
*   **Kompilator (ARM64 Cross):** `aarch64-linux-gnu-g++` (lub podobny cross-kompilator GCC)
*   **System budowania:** CMake
*   **Biblioteki:** SDL2 (dla Windows i skompilowane dla ARM64), OpenGL (Windows), OpenGL ES (ARM64)
*   **Edytor:** Visual Studio Code
*   **Debuger:** GDB (natywny i cross-debugger)

Ten zestaw narzędzi, choć z pozoru obszerny, jest faktycznie minimalnym wymaganiem dla efektywnej pracy z C++ na Windowsie i cross-kompilacji na ARM64, jednocześnie spełniając Twoje wymagania dotyczące OpenGL i SDL2.