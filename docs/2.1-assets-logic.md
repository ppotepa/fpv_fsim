# 2.1 Enhanced Asset Logic and Package Management

## Overview

This document outlines the enhanced asset logic and package management system for the FPV Flight Simulator, emphasizing the integration of declarative XML scene authoring with high-performance C++ implementations through the code-behind behavior system. The architecture provides modularity, determinism, and optimal performance across development and production environments.

## 2.1.1 Core Architectural Principles

### Enhanced Design Philosophy

The enhanced asset system builds upon the foundational principles while introducing sophisticated code-behind capabilities:

**Asset Identity Management**: Runtime operations use stable numeric IDs (`AssetId`, `SceneId`, `EntityId`) rather than string lookups, ensuring ultra-fast asset resolution and minimal memory overhead.

**Declarative Scene Authoring**: XML-based scene definitions enable rapid prototyping and iteration while maintaining strict type safety and validation through schema enforcement.

**Code-Behind Integration**: Seamless bridging between XML declarations and C++ implementations through behavior registration and parameter binding systems.

**Dual-Mode Operation**: Unified codebase supporting both development (hot-reload XML) and production (pre-compiled binary packages) workflows.

**Hierarchical Package Structure**: Clean separation between reusable assets and scene compositions, enabling efficient asset sharing and dependency management.

### Enhanced Package Architecture

```
packages/
├── core/                               # Core engine assets and behaviors
│   ├── package.xml                     # Core package definition
│   ├── assets/
│   │   ├── shaders/                    # Standard rendering shaders
│   │   │   ├── standard_lit.glsl       # PBR lighting shader
│   │   │   ├── unlit.glsl             # Unlit rendering shader
│   │   │   └── debug.glsl             # Debug visualization shader
│   │   ├── materials/                  # Default material definitions
│   │   │   ├── default_material.xml    # Default PBR material
│   │   │   ├── debug_material.xml      # Debug wireframe material
│   │   │   └── skybox_material.xml     # Skybox material
│   │   ├── meshes/                     # Primitive mesh definitions
│   │   │   ├── cube.xml               # Cube primitive
│   │   │   ├── sphere.xml             # Sphere primitive
│   │   │   └── plane.xml              # Plane primitive
│   │   └── textures/                   # Core texture assets
│   │       ├── default_albedo.png     # Default albedo texture
│   │       ├── default_normal.png     # Default normal map
│   │       └── noise_texture.png      # Procedural noise texture
│   └── behaviors/                      # Core behavior implementations
│       ├── TransformController.cpp     # Basic transform manipulation
│       ├── CameraController.cpp        # Camera movement and control
│       └── LightController.cpp         # Dynamic lighting control
├── environment/                        # Environmental systems package
│   ├── package.xml
│   ├── assets/
│   │   ├── terrain/                    # Terrain generation assets
│   │   │   ├── heightmaps/            # Terrain height data
│   │   │   ├── materials/             # Terrain materials
│   │   │   └── textures/              # Terrain texture arrays
│   │   ├── weather/                    # Weather system assets
│   │   │   ├── cloud_textures/        # Cloud texture atlas
│   │   │   ├── particle_systems/     # Weather particle definitions
│   │   │   └── audio/                 # Weather sound effects
│   │   └── lighting/                   # Environmental lighting
│   │       ├── hdri/                  # HDR environment maps
│   │       ├── sun_configs/           # Sun positioning data
│   │       └── atmosphere/            # Atmospheric scattering
│   └── behaviors/
│       ├── TerrainGenerator.cpp        # Procedural terrain generation
│       ├── WeatherSystem.cpp          # Dynamic weather simulation
│       ├── TimeOfDayController.cpp    # Day/night cycle management
│       └── WindSystem.cpp             # Wind simulation and effects
├── vehicles/                           # Vehicle systems package
│   ├── package.xml
│   ├── assets/
│   │   ├── models/                     # 3D vehicle models
│   │   │   ├── quadcopter/            # Quadcopter models and variants
│   │   │   ├── fixed_wing/            # Fixed-wing aircraft models
│   │   │   └── helicopter/            # Helicopter models
│   │   ├── textures/                   # Vehicle texture libraries
│   │   │   ├── liveries/              # Vehicle paint schemes
│   │   │   ├── materials/             # Material texture sets
│   │   │   └── decals/                # Decal and marking textures
│   │   ├── audio/                      # Vehicle sound libraries
│   │   │   ├── engines/               # Engine sound variations
│   │   │   ├── rotors/                # Rotor and propeller sounds
│   │   │   └── effects/               # Impact and effect sounds
│   │   └── physics/                    # Physics configuration data
│   │       ├── mass_properties/       # Mass and inertia data
│   │       ├── aerodynamics/          # Aerodynamic coefficients
│   │       └── control_surfaces/      # Control surface definitions
│   └── behaviors/
│       ├── QuadcopterController.cpp    # Quadcopter flight control
│       ├── FixedWingController.cpp    # Fixed-wing flight dynamics
│       ├── FlightDynamics.cpp         # General flight physics
│       ├── AutoPilot.cpp              # Autonomous flight systems
│       └── LandingSystem.cpp          # Automated landing procedures
└── developer/                         # Development and testing package
    ├── package.xml
    ├── assets/
    │   ├── debug/                      # Debug visualization assets
    │   │   ├── wireframes/            # Wireframe rendering materials
    │   │   ├── gizmos/                # Debug gizmo models
    │   │   └── overlays/              # UI overlay elements
    │   ├── test/                       # Test scenes and assets
    │   │   ├── simple_scenes/         # Basic test environments
    │   │   ├── stress_tests/          # Performance testing assets
    │   │   └── validation/            # System validation scenes
    │   └── tools/                      # Development tool assets
    │       ├── profiler/              # Performance profiling tools
    │       ├── inspector/             # Runtime inspection tools
    │       └── recorder/              # Session recording tools
    └── behaviors/
        ├── DebugCamera.cpp             # Debug camera controller
        ├── PerformanceMonitor.cpp      # Performance monitoring
        ├── SceneValidator.cpp          # Scene validation tools
        ├── AssetInspector.cpp          # Asset inspection utilities
        └── TestRunner.cpp              # Automated testing framework
```

## 2.1.2 Asset Identity and Resolution System

### Enhanced Asset ID Management

```cpp
// Asset identification system
using AssetId = uint64_t;
using SceneId = uint32_t;
using EntityId = uint32_t;
using BehaviorId = uint32_t;

class AssetIdGenerator {
public:
    // Generate stable IDs from string identifiers
    static AssetId generateAssetId(const std::string& packageId, 
                                 const std::string& assetId) {
        // Use stable hash function for deterministic ID generation
        uint64_t packageHash = fnv1a_hash(packageId);
        uint64_t assetHash = fnv1a_hash(assetId);
        
        // Combine hashes to create unique asset ID
        return (packageHash << 32) | (assetHash & 0xFFFFFFFF);
    }
    
    static SceneId generateSceneId(const std::string& packageId, 
                                 const std::string& sceneId) {
        std::string combined = packageId + ":" + sceneId;
        return static_cast<SceneId>(fnv1a_hash(combined));
    }
    
    static EntityId generateEntityId(const std::string& sceneId, 
                                   const std::string& entityId) {
        std::string combined = sceneId + ":" + entityId;
        return static_cast<EntityId>(fnv1a_hash(combined));
    }

private:
    static uint64_t fnv1a_hash(const std::string& str) {
        const uint64_t FNV_offset_basis = 14695981039346656037ULL;
        const uint64_t FNV_prime = 1099511628211ULL;
        
        uint64_t hash = FNV_offset_basis;
        for (char c : str) {
            hash ^= static_cast<uint64_t>(c);
            hash *= FNV_prime;
        }
        return hash;
    }
};
```

### Asset Resolution and Caching

```cpp
class AssetRegistry {
public:
    // Asset registration and lookup
    void registerAsset(AssetId id, std::shared_ptr<Asset> asset) {
        std::lock_guard<std::shared_mutex> lock(registryMutex);
        assetRegistry[id] = asset;
    }
    
    std::shared_ptr<Asset> resolveAsset(AssetId id) const {
        std::shared_lock<std::shared_mutex> lock(registryMutex);
        auto it = assetRegistry.find(id);
        return (it != assetRegistry.end()) ? it->second : nullptr;
    }
    
    template<typename T>
    std::shared_ptr<T> resolveAsset(AssetId id) const {
        auto asset = resolveAsset(id);
        return std::dynamic_pointer_cast<T>(asset);
    }
    
    // Asset reference resolution
    std::optional<AssetId> resolveAssetReference(const std::string& packageId,
                                               const std::string& assetRef) const {
        AssetId id = AssetIdGenerator::generateAssetId(packageId, assetRef);
        
        std::shared_lock<std::shared_mutex> lock(registryMutex);
        auto it = assetRegistry.find(id);
        return (it != assetRegistry.end()) ? std::optional<AssetId>{id} : std::nullopt;
    }
    
    // Dependency resolution
    std::vector<AssetId> resolveDependencies(AssetId id) const {
        std::shared_lock<std::shared_mutex> lock(registryMutex);
        auto it = dependencyGraph.find(id);
        return (it != dependencyGraph.end()) ? it->second : std::vector<AssetId>{};
    }

private:
    mutable std::shared_mutex registryMutex;
    std::unordered_map<AssetId, std::shared_ptr<Asset>> assetRegistry;
    std::unordered_map<AssetId, std::vector<AssetId>> dependencyGraph;
};
```

## 2.1.3 Asset Loading and Compilation Pipeline

### Asset Compilation Architecture

```cpp
class AssetCompilationPipeline {
public:
    struct CompilationConfig {
        bool developmentMode = false;
        bool enableOptimization = true;
        bool enableHotReload = false;
        bool generateDebugInfo = false;
        std::string outputDirectory;
        std::string cacheDirectory;
    };
    
    struct CompilationResult {
        bool success;
        std::vector<AssetId> compiledAssets;
        std::vector<std::string> errors;
        std::vector<std::string> warnings;
        CompilationStats statistics;
    };
    
    CompilationResult compilePackage(const std::string& packagePath,
                                   const CompilationConfig& config) {
        CompilationResult result;
        
        try {
            // Parse package definition
            auto packageDef = parsePackageDefinition(packagePath);
            validatePackageDefinition(packageDef, result);
            
            if (!result.errors.empty()) {
                result.success = false;
                return result;
            }
            
            // Build compilation context
            CompilationContext context(packageDef, config);
            
            // Compile assets in dependency order
            auto compilationOrder = computeCompilationOrder(packageDef);
            for (const auto& assetDef : compilationOrder) {
                compileAsset(assetDef, context, result);
            }
            
            // Compile scenes
            for (const auto& sceneDef : packageDef.scenes) {
                compileScene(sceneDef, context, result);
            }
            
            // Generate package binary
            if (result.errors.empty()) {
                generatePackageBinary(packageDef, context, result);
            }
            
            result.success = result.errors.empty();
            
        } catch (const std::exception& e) {
            result.errors.push_back("Compilation failed: " + std::string(e.what()));
            result.success = false;
        }
        
        return result;
    }

private:
    void compileAsset(const AssetDefinition& assetDef,
                     CompilationContext& context,
                     CompilationResult& result) {
        
        switch (assetDef.type) {
            case AssetType::Material:
                compileMaterialAsset(assetDef, context, result);
                break;
            case AssetType::Mesh:
                compileMeshAsset(assetDef, context, result);
                break;
            case AssetType::Texture:
                compileTextureAsset(assetDef, context, result);
                break;
            case AssetType::Shader:
                compileShaderAsset(assetDef, context, result);
                break;
            case AssetType::Audio:
                compileAudioAsset(assetDef, context, result);
                break;
            default:
                result.errors.push_back("Unknown asset type: " + 
                                       std::to_string(static_cast<int>(assetDef.type)));
        }
    }
    
    void compileMaterialAsset(const AssetDefinition& assetDef,
                            CompilationContext& context,
                            CompilationResult& result) {
        
        auto materialData = std::get<MaterialAssetData>(assetDef.data);
        
        // Resolve shader dependencies
        auto shaderId = context.resolveAssetReference(materialData.shaderReference);
        if (!shaderId.has_value()) {
            result.errors.push_back("Material " + assetDef.id + 
                                   " references unknown shader: " + 
                                   materialData.shaderReference);
            return;
        }
        
        // Resolve texture dependencies
        std::vector<AssetId> textureIds;
        for (const auto& textureRef : materialData.textureReferences) {
            auto textureId = context.resolveAssetReference(textureRef.second);
            if (textureId.has_value()) {
                textureIds.push_back(textureId.value());
            } else {
                result.warnings.push_back("Material " + assetDef.id + 
                                         " references unknown texture: " + 
                                         textureRef.second);
            }
        }
        
        // Compile material to binary format
        CompiledMaterial compiledMaterial;
        compiledMaterial.id = AssetIdGenerator::generateAssetId(
            context.getPackageId(), assetDef.id);
        compiledMaterial.shaderId = shaderId.value();
        compiledMaterial.textureIds = textureIds;
        compiledMaterial.properties = serializeMaterialProperties(materialData.properties);
        
        // Store compiled asset
        context.storeCompiledAsset(compiledMaterial);
        result.compiledAssets.push_back(compiledMaterial.id);
    }
};
```

### Hot-Reload System Integration

```cpp
class AssetHotReloadSystem {
public:
    void initialize(const std::string& packagesDirectory) {
        // Initialize file system watcher
        fileWatcher = std::make_unique<FileSystemWatcher>(packagesDirectory);
        
        // Set up change handlers
        fileWatcher->onFileChanged([this](const std::string& filePath) {
            scheduleAssetReload(filePath);
        });
        
        fileWatcher->onFileAdded([this](const std::string& filePath) {
            scheduleAssetReload(filePath);
        });
        
        fileWatcher->onFileRemoved([this](const std::string& filePath) {
            scheduleAssetRemoval(filePath);
        });
        
        // Start monitoring
        fileWatcher->startWatching();
    }
    
    void update(float deltaTime) {
        reloadBatchTimer += deltaTime;
        
        // Process batched reloads at regular intervals
        if (reloadBatchTimer >= RELOAD_BATCH_INTERVAL && !pendingReloads.empty()) {
            processPendingReloads();
            reloadBatchTimer = 0.0f;
        }
    }

private:
    void scheduleAssetReload(const std::string& filePath) {
        std::lock_guard<std::mutex> lock(reloadMutex);
        
        // Determine affected assets
        auto affectedAssets = analyzeFileChange(filePath);
        
        for (const auto& assetId : affectedAssets) {
            pendingReloads.insert(assetId);
        }
    }
    
    void processPendingReloads() {
        std::lock_guard<std::mutex> lock(reloadMutex);
        
        if (pendingReloads.empty()) return;
        
        // Compile affected assets
        AssetCompilationPipeline compiler;
        AssetCompilationPipeline::CompilationConfig config;
        config.developmentMode = true;
        config.enableHotReload = true;
        
        for (const auto& assetId : pendingReloads) {
            recompileAsset(assetId, compiler, config);
        }
        
        // Notify systems of asset changes
        EventBus::instance().emit(AssetsReloadedEvent{
            std::vector<AssetId>(pendingReloads.begin(), pendingReloads.end())
        });
        
        pendingReloads.clear();
    }
    
    std::unique_ptr<FileSystemWatcher> fileWatcher;
    std::mutex reloadMutex;
    std::unordered_set<AssetId> pendingReloads;
    float reloadBatchTimer = 0.0f;
    static constexpr float RELOAD_BATCH_INTERVAL = 0.5f; // 500ms batching
};
```

This enhanced asset logic provides the foundation for the package modularity architecture, enabling efficient asset management, compilation, and hot-reload capabilities while maintaining optimal runtime performance.

To achieve high performance and determinism, the runtime avoids string lookups:

*   **Stable IDs**: Each asset is identified by a `uint32_t` (or `uint64_t`) `AssetId`. These are generated by the **asset compiler** using a perfect hash or assigned index table.
*   **Autogenerated Header/Table**: A small binary table or an autogenerated header maps compile-time symbolic names to these `AssetId`s for code use.
*   **AssetRegistry**: Stores `{AssetId -> ResourceHandle}` with reference counts, without storing strings in runtime tables.

#### **4. Intermediate Representation (IR) and Binary Pack Format:**

The asset compiler transforms XML into an in-memory **Intermediate Representation (IR)**, which is then used to either build live resources (debug) or "cook" them into a `.pak` binary pack (release):

*   **`.pak` Layout (Memory-Mappable)**:
    *   **Header**: Magic number, version, sections count.
    *   **Section Directory**: Fixed offsets for `ASSET_TABLE` (mapping `AssetId` to type, offset, size, flags), `GEOMETRY` (mesh buffers), `MATERIALS`, `TEXTURES`, `PARAMS` (prebaked parameter blocks), `SHADERS`, and `META` (hashes, build info).
*   **Cooking Process**:
    *   **Geometry**: Applies quantization, mesh reordering (e.g., `meshoptimizer` style), generates multi-LODs, and stores data in Structure of Arrays (SoA) for vectorized uploads.
    *   **Textures**: Precompresses to device-friendly formats (e.g., ETC2/KTX2/Basis UASTC).
    *   **Parametric Assets (XML → geometry/logic)**: The asset compiler **executes param generators** (which must be deterministic) to produce final meshes or small parameter blocks + recipe opcode streams for runtime procedural expansion (prefer fully cooked for max speed).

#### **5. Integration with C++ Codebase:**

The integration of XML-defined assets and configurations into the C++ architecture follows IoC, ECS, and Event-Driven Communication principles:

1.  **XML Parsing and Data Loading**: A dedicated **XML parsing module** (e.g., using TinyXML2 or RapidXML) loads XML files from `packages/` and `world_gen/` directories. Parsed data is loaded into appropriate **data structures** (e.g., `SceneConfig`, `ComponentConfig`, `AssetParams`).
2.  **ECS Integration (Entities and Components)**:
    *   Parsed component XML data (e.g., `drone_x1_components.xml`) is consumed by an **Entity Factory** or **Vehicle Spawner** system.
    *   When an `AerichalVehicle` (an ECS entity) is created, the factory reads the XML config, instantiates necessary **Components** (e.g., `PropulsionUnitC`, `BatteryC`, `SensorsC`), and attaches them.
    *   Each component's data members are **populated directly from the parsed XML values**, making vehicle behavior data-driven.
3.  **IoC and Dependency Injection**:
    *   Systems rely on **abstractions (interfaces)**. The IoC Container (or "Poor Man's DI" approach) uses **constructor injection** to provide concrete component instances (initialized from XML data) to systems like `PhysicsSystem` or `WorldGenSystem`. This allows systems to perform calculations using XML-defined parameters without knowing their origin.
    *   For example, `WorldGenSystem` would be injected with `SceneConfig` data, enabling it to generate the environment according to XML specifications.
4.  **Asset Loading and Management**: XML files define paths to 3D models, textures, shaders, and sounds. An **AssetLoader** service reads these paths, uses underlying libraries (e.g., SDL2, OpenGL ES) to load raw asset data, and makes them available to systems like `VisualizationSystem`. Optimizations like Object Pooling, Spatial Partitioning, and LOD are applied.
5.  **Event-Driven Communication**: Components and systems, configured by XML, can **subscribe to events** published to the `global EventBus` (e.g., `BatteryLow`, `HardImpact`).

#### **6. Two Modes: Debug Path (XML Hot-Reload) & Release Path (Binary Packs + Plugins):**

*   **Debug Path (XML Hot-Reload)**:
    *   A **file watcher** detects changes to XML files.
    *   On change, the system parses the XML, validates it, converts it to IR, and runs the **exact same "cook passes"** as the asset compiler.
    *   Resources are built into a **staging registry**.
    *   At the `EndOfFrame` (after `VisualizationSystem`), an **atomic commit** occurs: registry pointers are swapped (double-buffering), ECS handles are repointed, and a `HotReloadEvent` is emitted.
    *   **Determinism Rule**: Live registries are never mutated mid-frame.
*   **Release Path (Binary Packs + Plugins)**:
    *   An **Asset compiler** (CLI tool) converts `packages/*` into `*.pak` binary packs.
    *   Code modules (`code/*.cpp`) are cross-compiled into `lib_*.so` plugins for ARM64.
    *   The runtime's `AssetPackLoader` **memory-maps** `.pak` files and registers sections.
    *   A `PluginManager` scans `/runtime/data/plugins/` and uses `dlopen()` to load each `.so` plugin. Plugins export a **stable C ABI** for registration.
    *   **No JIT on device**: Pre-built `.so` files are preferred due to tight ARM64 memory/CPU budgets.

#### **7. IoC/DI & ECS Integration with Assets (Code Examples):**

The asset system integrates seamlessly with IoC and ECS:

*   **IoC Container**: Built at boot with core services (`AssetRegistry`, `Physics`, `WorldGenApi`, etc.). The `PluginManager` constructs **child containers** for plugins, which register factories and systems via interfaces. Dependencies are injected via constructors.
    *   **Example (Pseudocode)**:
        ```cpp
        struct INoise : Interface { virtual float sample(float2 p)=0; };

        struct TerrainGen : ITerrainGen { TerrainGen(INoise& n, IJobSystem& jobs); ... }

        void CityPluginRegister(PluginApi* api) {
            api->RegisterFactory([] (IContainer& c) { return new PerlinNoise(...); });
            api->RegisterFactory([] (IContainer& c) {
                return new TerrainGen(c.get(), c.get());
            });
            api->RegisterSystem(&CityTrafficSystemDesc); // system depends on ITerrainGen
        }
        ```
*   **ECS with Dynamic Components**: A `PluginComponent` pattern allows for dynamic data:
    *   `struct PluginComponent { ComponentTypeId type; void* data; const ComponentVTable* vtbl; }`
    *   `ComponentVTable` holds function pointers (`onAdd`, `onRemove`, `serialize`, `tick`).
*   **Entity/Vehicle Factory**: Extended to accept `ComponentBlueprint` (from XML or baked pack). It looks up `ComponentTypeId` by numeric ID, allocates component storage via the plugin's `onAdd()`, and passes in the **binary param block** (not strings).

#### **8. Affected Files & Code Examples:**

The assets logic primarily affects the following types of files and modules:

*   **XML Configuration Files**:
    *   `packages/<package_name>/package.xml`
    *   `packages/<package_name>/params/*.xml` (e.g., `building_city_block.xml`, `drone_x1_components.xml`, `table.xml`)
*   **Binary Asset Files (Release)**:
    *   `runtime/data/packs/<package_name>.pak`
    *   `runtime/data/plugins/lib_<plugin_name>.so`
*   **C++ Source Files / Modules**:
    *   **`asset_compiler` (CLI tool)**: Responsible for `xml -> IR -> cooked binaries`.
    *   **`codegen` module**: Generates headers/tables for `AssetId`s.
    *   **XML Parsing Module**: Loads and parses XMLs into data structures.
    *   **`AssetPackLoader`**: Memory-maps `.pak` files and registers sections.
    *   **`PluginManager`**: Scans, loads (`dlopen`), and manages plugins, constructing child IoC containers.
    *   **`AssetRegistry`**: Stores `AssetId -> ResourceHandle` mappings.
    *   **Entity/Vehicle Factory**: Consumes `ComponentBlueprints` (binary param blobs, TypeIds).
    *   **`BootstrapSystem`**: One-shot system to load core packs, build IoC, load plugins, construct world.
    *   **`AssetHotReloadSystem`**: End-of-frame system for debug hot-reloading (file watching, cooking to staging, atomic commit).
    *   **`main.cpp` / `SimApp.cpp`**: Orchestrates the main loop, including `BootstrapSystem` and `AssetHotReloadSystem`.
    *   **Core Systems (`PhysicsSystem`, `WorldGenSystem`, `VehicleControlSystem`)**: Consume asset data and interfaces injected via IoC.
    *   **Component Implementations (`PropulsionUnitC`, `BatteryC`, `SensorsC`, etc.)**: Their data members are populated from XML/binary pack configs.

*   **Code Examples for Plugin API and Hot-Reload System**:

    ```cpp
    // Plugin API (Shared between engine and plugins)
    struct ComponentVTable {
        void (*onAdd)(Entity e, const void* paramBlob, size_t bytes);
        void (*onRemove)(Entity e);
        void (*serialize)(Entity e, IWriter*);
        void (*tick)(Entity e, float dt); // optional, or system-based
    };

    struct SystemDescriptor {
        const char* name; // debug only
        void (*onRegister)(IWorld*);
        void (*onTick)(IWorld*, float dt);
        ComponentTypeId* readSet; // array of component type IDs
        ComponentTypeId* writeSet;
    };

    // Plugin entry points (Stable C ABI)
    extern "C" bool RegisterPlugin(PluginApi* api, uint32_t apiVersion);
    extern "C" void UnregisterPlugin(PluginApi* api);

    // AssetHotReloadSystem Tick Method
    void AssetHotReloadSystem::TickEndOfFrame()
    {
        if (watcher.hasChanges()) {
            Staging s;
            for (auto& change : watcher.consume()) {
                if (isXML(change)) cookToIR(change, s);
                if (isCode(change)) buildPluginSo(change, s); // optional remote build
            }
            // Build/update staging registry from IR (same passes as tool)
            buildStagingRegistry(s);

            // Commit atomically
            registry.swapWith(s.registry);
            pluginManager.commit(s.plugins); // dlopen/dlsym here
            eventBus.emit(HotReloadEvent{});
        }
    }
    ```

---